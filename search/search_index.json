{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-swoole\n\n\n\n\n\n\nThis library provides the support of \nSwoole\n into\nan \nExpressive\n application. This means you can\nexecute your Expressive application using Swoole directly from the command line.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nConfiguration\n\n\nAfter installing zend-expressive-swoole, you will need to first enable the\ncomponent, and then optionally configure it.\n\n\nWe recommend adding a new configuration file to your autoload directory,\n\nconfig/autoload/swoole.local.php\n. To begin with, use the following contents:\n\n\n<?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), []);\n\n\n\nThe above will setup the Swoole integration for your application.\n\n\nBy default, Swoole executes the HTTP server with host \n127.0.0.1\n on port\n\n8080\n. You can change these values via configuration. Assuming you have the\nabove, modify it to read as follows:\n\n\n<?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => 'insert hostname to use here',\n            'port' => 80, // use an integer value here\n        ],\n    ],\n]);\n\n\n\n\n\nExpressive skeleton 3.1.0 and later\n\n\nIf you have built your application on the 3.1.0 or later version of the\nExpressive skeleton, you do not need to instantiate and invoke the package's\n\nConfigProvider\n, as the skeleton supports it out of the box.\n\n\nYou will only need to provide any additional configuration of the HTTP server.\n\n\n\n\nExecute\n\n\nOnce you have performed the configuration steps as outlined above, you can run\nan Expressive application with Swoole using the following command:\n\n\nphp public/index.php\n\n\n\nDocumentation\n\n\nBrowse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/\n\n\nSupport\n\n\n\n\nIssues\n\n\nChat\n\n\nForum",
            "title": "zend-expressive-swoole"
        },
        {
            "location": "/#zend-expressive-swoole",
            "text": "This library provides the support of  Swoole  into\nan  Expressive  application. This means you can\nexecute your Expressive application using Swoole directly from the command line.",
            "title": "zend-expressive-swoole"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-swoole",
            "title": "Installation"
        },
        {
            "location": "/#configuration",
            "text": "After installing zend-expressive-swoole, you will need to first enable the\ncomponent, and then optionally configure it.  We recommend adding a new configuration file to your autoload directory, config/autoload/swoole.local.php . To begin with, use the following contents:  <?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), []);  The above will setup the Swoole integration for your application.  By default, Swoole executes the HTTP server with host  127.0.0.1  on port 8080 . You can change these values via configuration. Assuming you have the\nabove, modify it to read as follows:  <?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => 'insert hostname to use here',\n            'port' => 80, // use an integer value here\n        ],\n    ],\n]);",
            "title": "Configuration"
        },
        {
            "location": "/#expressive-skeleton-310-and-later",
            "text": "If you have built your application on the 3.1.0 or later version of the\nExpressive skeleton, you do not need to instantiate and invoke the package's ConfigProvider , as the skeleton supports it out of the box.  You will only need to provide any additional configuration of the HTTP server.",
            "title": "Expressive skeleton 3.1.0 and later"
        },
        {
            "location": "/#execute",
            "text": "Once you have performed the configuration steps as outlined above, you can run\nan Expressive application with Swoole using the following command:  php public/index.php",
            "title": "Execute"
        },
        {
            "location": "/#documentation",
            "text": "Browse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/",
            "title": "Documentation"
        },
        {
            "location": "/#support",
            "text": "Issues  Chat  Forum",
            "title": "Support"
        },
        {
            "location": "/intro/",
            "text": "Swoole\n\n\nSwoole\n is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.\n\n\nInstall swoole\n\n\nYou can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:\n\n\n$ pecl install swoole\n\n\n\nFor more information on the extension, \nvisit its package details on PECL\n.\n\n\nInstall zend-expressive-swoole\n\n\nTo install this package, use \nComposer\n:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nSwoole with Expressive\n\n\nzend-expressive-swoole enables an Expressive application to be executed with\nthe \nSwoole\n extension. This means you can run the\napplication from the command line, \nwithout requiring a web server\n.\n\n\nYou can run the application using the following command:\n\n\n$ php public/index.php\n\n\n\nThis command will execute Swoole on \nlocalhost\n via port \n8080\n.\n\n\n\n\nExpressive skeleton versions prior to 3.1.0\n\n\nThe above will work immediately after installing zend-expressive-swoole if you\nare using a version of \nzend-expressive-skeleton\n\nfrom 3.1.0 or later.\n\n\nFor applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as \nconfig/autoload/zend-expressive-swoole.global.php\n\nor \nconfig/autoload/zend-expressive-swoole.local.php\n with the following\ncontents:\n\n\n<?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();\n\n\n\n\n\nYou can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:\n\n\n// In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];\n\n\n\nProviding additional Swoole configuration\n\n\nYou can also configure the Swoole HTTP server using an \noptions\n key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:\n\n\n// config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE,\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL,\n            'options' => [\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n            ],\n        ],\n    ],\n];\n\n\n\nServing static files\n\n\nWe support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant\n\nZend\\Expressive\\Swoole\\StaticResourceHandler::DEFAULT_STATIC_EXTS\n, which\nis derived from a \nlist of common web MIME types maintained by Mozilla\n.\nOur static resource capabilities are fairly comprehensive; please see the\n\nchapter on static resources\n for full details on\nconfiguration.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#swoole",
            "text": "Swoole  is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.",
            "title": "Swoole"
        },
        {
            "location": "/intro/#install-swoole",
            "text": "You can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:  $ pecl install swoole  For more information on the extension,  visit its package details on PECL .",
            "title": "Install swoole"
        },
        {
            "location": "/intro/#install-zend-expressive-swoole",
            "text": "To install this package, use  Composer :  $ composer require zendframework/zend-expressive-swoole",
            "title": "Install zend-expressive-swoole"
        },
        {
            "location": "/intro/#swoole-with-expressive",
            "text": "zend-expressive-swoole enables an Expressive application to be executed with\nthe  Swoole  extension. This means you can run the\napplication from the command line,  without requiring a web server .  You can run the application using the following command:  $ php public/index.php  This command will execute Swoole on  localhost  via port  8080 .",
            "title": "Swoole with Expressive"
        },
        {
            "location": "/intro/#expressive-skeleton-versions-prior-to-310",
            "text": "The above will work immediately after installing zend-expressive-swoole if you\nare using a version of  zend-expressive-skeleton \nfrom 3.1.0 or later.  For applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as  config/autoload/zend-expressive-swoole.global.php \nor  config/autoload/zend-expressive-swoole.local.php  with the following\ncontents:  <?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();   You can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:  // In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];",
            "title": "Expressive skeleton versions prior to 3.1.0"
        },
        {
            "location": "/intro/#providing-additional-swoole-configuration",
            "text": "You can also configure the Swoole HTTP server using an  options  key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:  // config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE,\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL,\n            'options' => [\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n            ],\n        ],\n    ],\n];",
            "title": "Providing additional Swoole configuration"
        },
        {
            "location": "/intro/#serving-static-files",
            "text": "We support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant Zend\\Expressive\\Swoole\\StaticResourceHandler::DEFAULT_STATIC_EXTS , which\nis derived from a  list of common web MIME types maintained by Mozilla .\nOur static resource capabilities are fairly comprehensive; please see the chapter on static resources  for full details on\nconfiguration.",
            "title": "Serving static files"
        },
        {
            "location": "/static-resources/",
            "text": "Static Resources\n\n\nOne feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.\n\n\nTo enable this, the package provides an alternate\n\nRequestHandlerRunner\n\nimplementation via the class \nZend\\Expressive\\Swoole\\RequestHandlerSwooleRunner\n\nthat performs two duties:\n\n\n\n\nIf a static resource is matched, it serves that.\n\n\nOtherwise, it passes off handling to the composed application pipeline.\n\n\n\n\nInternally, the \nRequestHandlerSwooleRunner\n composes another class, a \n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n instance. This instance\nis first queried to determine if a static resource was matched, and, if so, then\ninvoked in order to serve it.\n\n\nOur default implementation, \nZend\\Expressive\\Swoole\\StaticResourceHandler\n,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.\n\n\nMiddleware\n\n\nThe \nStaticResourceHandler\n implementation also provides the ability to compose\na queue of middleware to execute when attempting to serve a matched file.  Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:\n\n\n\n\n\n\nCacheControlMiddleware\n will set a \nCache-Control\n header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the \nCache-Control\n directive to\n  use when the match occurs.\n\n\n\n\n\n\nClearStatCacheMiddleware\n will, if configured to do so, call\n  \nclearstatcache()\n either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.\n\n\n\n\n\n\nETagMiddleware\n will set an \nETag\n header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the \nETag\n\n  header value matches either an \nIf-Match\n or \nIf-None-Match\n request header,\n  it will provide a response status of \n304\n and disable sending content.\n\n\n\n\n\n\nGzipMiddleware\n detects the \nAccept-Encoding\n request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.\n\n\n\n\n\n\nHeadMiddleware\n will force an empty response. (The status and headers may be\n  set by other middleware.)\n\n\n\n\n\n\nLastModifiedMiddleware\n will set a \nLast-Modified\n header using the\n  \nfilemtime()\n value of the requested resource. If the header value is later\n  than an \nIf-Modified-Since\n  request header, it will provide a response status\n  of \n304\n and disable sending content.\n\n\n\n\n\n\nMethodNotAllowedMiddleware\n will set the response status to \n405\n, and set an\n  \nAllow\n header indicating the allowed methods when an unsupported request\n  method is provided.\n\n\n\n\n\n\nOptionsMiddleware\n will force an empty response with an \nAllow\n header set\n  to the allowed methods. (Other headers may also be present!)\n\n\n\n\n\n\nBy default, these are registered in the following order, contingent on\nconfiguration being provided:\n\n\n\n\nMethodNotAllowedMiddleware\n\n\nOptionsMiddleware\n\n\nHeadMiddleware\n\n\nGzipMiddleware\n\n\nClearStatCacheMiddleware\n\n\nCacheControlMiddleware\n\n\nLastModifiedMiddleware\n\n\nETagMiddleware\n\n\n\n\nThis approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the \nLast-Modified\n or \nETag\n headers); it also\nensures that all possible headers are provided whenever possible (e.g., a \nHEAD\n\nrequest should also expose \nCache-Control\n, \nLast-Modified\n, and \nETag\n\nheaders).\n\n\n\n\nProviding your own middleware\n\n\nIf you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate\n\nStaticResourceHandler\n factory. In most cases, you can extend\n\nStaticResourceHandlerFactory\n and override the \nconfigureMiddleware(array\n$config) : array\n method to do so. Be sure to remember to add a \ndependencies\n\nsetting mapping the \nStaticResourceHandlerInterface\n service to your new factory\nwhen done!\n\n\n\n\nConfiguration\n\n\nWe provide a factory for the \nStaticResourceHandler\n that uses a\nconfiguration-driven approach in order to:\n\n\n\n\nSet the document root.\n\n\nSet the map of allowed extensions to content-types.\n\n\nConfigure and provide middleware.\n\n\n\n\nThe following demonstrates all currently available configuration options:\n\n\n// config/autoload/swoole.local.php\nuse Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner;\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nSecurity warning\n\n\nNever add \nphp\n as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!\n\n\nDocument root\n\n\nIf no \ndocument_root\n configuration is present, the default is to use\n\ngetcwd() . '/public'\n. If either the configured or default document root\ndoes not exist, we raise an exception.\n\n\nDefault extension/content-types\n\n\nBy default, we serve files with extensions in the whitelist defined in the\nconstant \nZend\\Expressive\\Swoole\\StaticResourceHandler::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\n\n\n\n\nConfiguration Example\n\n\nThe example which follows provides the following options:\n\n\n\n\nSets the document root to \n/var/www/htdocs\n.\n\n\nAdds a custom extension / content-type map.\n\n\nProvides a clearstatcache interval of 2 hours.\n\n\nSelects the \"strong\" ETag algorithm.\n\n\nIndicates a gzip compression level of 3.\n\n\nSets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.\n\n\nSets Cache-Control directives for plain text files.\n\n\n\n\n// config/autoload/swoole.local.php\nuse Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner;\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nWriting Middleware\n\n\nStatic resource middleware must implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface\n, which\ndefines the following:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}\n\n\n\nThe \n$next\n argument has the following signature:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;\n\n\n\nTypically, middleware will look something like this:\n\n\n$response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.\n\n\n\nMiddleware either produces or manipulates a\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse\n instance.\nThat class looks like the following:\n\n\nclass StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    public function setStatus(int $status) : void;\n}\n\n\n\nMost middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via \ndisableContent()\n).\n\n\n\n\nProviding an alternative mechanism for sending response content\n\n\nIn some cases, you may want to alter how the \nSwoole\\Http\\Response\n receives the\nbody content. By default, we use \nSwoole\\Http\\Response::sendfile()\n. However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the \nGzipMiddleware\n adds a compression filter to\na filehandle representing the file to send, and then calls\n\nSwoole\\Http\\Response::write()\n in a loop until all content is sent.\n\n\nTo perform work like this, you can call the\n\nStaticResourceResponse::setResponseContentCallback()\n method as detailed in the\nsection above within your middleware.\n\n\n\n\nAlternative static resource handlers\n\n\nAs noted at the beginning of this chapter, the the \nRequestHandlerSwooleRunner\n\ncomposes a \nStaticResourceHandlerInterface\n instance in order to determine if a\nresource was matched by the request, and then to serve it.\n\n\nIf you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n:\n\n\ndeclare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Does the request match to a static resource?\n     */\n    public function isStaticResource(SwooleHttpRequest $request) : bool;\n\n    /**\n     * Send the static resource based on the current request.\n     */\n    public function sendStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : void;\n}\n\n\n\nOnce implemented, map the service\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n to a factory that\nreturns your custom implementation within your \ndependencies\n configuration.",
            "title": "Static Resources"
        },
        {
            "location": "/static-resources/#static-resources",
            "text": "One feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.  To enable this, the package provides an alternate RequestHandlerRunner \nimplementation via the class  Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner \nthat performs two duties:   If a static resource is matched, it serves that.  Otherwise, it passes off handling to the composed application pipeline.   Internally, the  RequestHandlerSwooleRunner  composes another class, a  Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  instance. This instance\nis first queried to determine if a static resource was matched, and, if so, then\ninvoked in order to serve it.  Our default implementation,  Zend\\Expressive\\Swoole\\StaticResourceHandler ,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.",
            "title": "Static Resources"
        },
        {
            "location": "/static-resources/#middleware",
            "text": "The  StaticResourceHandler  implementation also provides the ability to compose\na queue of middleware to execute when attempting to serve a matched file.  Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:    CacheControlMiddleware  will set a  Cache-Control  header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the  Cache-Control  directive to\n  use when the match occurs.    ClearStatCacheMiddleware  will, if configured to do so, call\n   clearstatcache()  either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.    ETagMiddleware  will set an  ETag  header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the  ETag \n  header value matches either an  If-Match  or  If-None-Match  request header,\n  it will provide a response status of  304  and disable sending content.    GzipMiddleware  detects the  Accept-Encoding  request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.    HeadMiddleware  will force an empty response. (The status and headers may be\n  set by other middleware.)    LastModifiedMiddleware  will set a  Last-Modified  header using the\n   filemtime()  value of the requested resource. If the header value is later\n  than an  If-Modified-Since   request header, it will provide a response status\n  of  304  and disable sending content.    MethodNotAllowedMiddleware  will set the response status to  405 , and set an\n   Allow  header indicating the allowed methods when an unsupported request\n  method is provided.    OptionsMiddleware  will force an empty response with an  Allow  header set\n  to the allowed methods. (Other headers may also be present!)    By default, these are registered in the following order, contingent on\nconfiguration being provided:   MethodNotAllowedMiddleware  OptionsMiddleware  HeadMiddleware  GzipMiddleware  ClearStatCacheMiddleware  CacheControlMiddleware  LastModifiedMiddleware  ETagMiddleware   This approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the  Last-Modified  or  ETag  headers); it also\nensures that all possible headers are provided whenever possible (e.g., a  HEAD \nrequest should also expose  Cache-Control ,  Last-Modified , and  ETag \nheaders).",
            "title": "Middleware"
        },
        {
            "location": "/static-resources/#providing-your-own-middleware",
            "text": "If you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate StaticResourceHandler  factory. In most cases, you can extend StaticResourceHandlerFactory  and override the  configureMiddleware(array\n$config) : array  method to do so. Be sure to remember to add a  dependencies \nsetting mapping the  StaticResourceHandlerInterface  service to your new factory\nwhen done!",
            "title": "Providing your own middleware"
        },
        {
            "location": "/static-resources/#configuration",
            "text": "We provide a factory for the  StaticResourceHandler  that uses a\nconfiguration-driven approach in order to:   Set the document root.  Set the map of allowed extensions to content-types.  Configure and provide middleware.   The following demonstrates all currently available configuration options:  // config/autoload/swoole.local.php\nuse Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner;\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/static-resources/#security-warning",
            "text": "Never add  php  as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!",
            "title": "Security warning"
        },
        {
            "location": "/static-resources/#document-root",
            "text": "If no  document_root  configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root\ndoes not exist, we raise an exception.",
            "title": "Document root"
        },
        {
            "location": "/static-resources/#default-extensioncontent-types",
            "text": "By default, we serve files with extensions in the whitelist defined in the\nconstant  Zend\\Expressive\\Swoole\\StaticResourceHandler::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .",
            "title": "Default extension/content-types"
        },
        {
            "location": "/static-resources/#configuration-example",
            "text": "The example which follows provides the following options:   Sets the document root to  /var/www/htdocs .  Adds a custom extension / content-type map.  Provides a clearstatcache interval of 2 hours.  Selects the \"strong\" ETag algorithm.  Indicates a gzip compression level of 3.  Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.  Sets Cache-Control directives for plain text files.   // config/autoload/swoole.local.php\nuse Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner;\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration Example"
        },
        {
            "location": "/static-resources/#writing-middleware",
            "text": "Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which\ndefines the following:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}  The  $next  argument has the following signature:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;  Typically, middleware will look something like this:  $response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.  Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse  instance.\nThat class looks like the following:  class StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    public function setStatus(int $status) : void;\n}  Most middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via  disableContent() ).",
            "title": "Writing Middleware"
        },
        {
            "location": "/static-resources/#providing-an-alternative-mechanism-for-sending-response-content",
            "text": "In some cases, you may want to alter how the  Swoole\\Http\\Response  receives the\nbody content. By default, we use  Swoole\\Http\\Response::sendfile() . However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the  GzipMiddleware  adds a compression filter to\na filehandle representing the file to send, and then calls Swoole\\Http\\Response::write()  in a loop until all content is sent.  To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback()  method as detailed in the\nsection above within your middleware.",
            "title": "Providing an alternative mechanism for sending response content"
        },
        {
            "location": "/static-resources/#alternative-static-resource-handlers",
            "text": "As noted at the beginning of this chapter, the the  RequestHandlerSwooleRunner \ncomposes a  StaticResourceHandlerInterface  instance in order to determine if a\nresource was matched by the request, and then to serve it.  If you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface :  declare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Does the request match to a static resource?\n     */\n    public function isStaticResource(SwooleHttpRequest $request) : bool;\n\n    /**\n     * Send the static resource based on the current request.\n     */\n    public function sendStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : void;\n}  Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  to a factory that\nreturns your custom implementation within your  dependencies  configuration.",
            "title": "Alternative static resource handlers"
        },
        {
            "location": "/logging/",
            "text": "Logging\n\n\nWeb servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.\n\n\nOut-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.\n\n\nWe log two items:\n\n\n\n\nWhen the web server starts, indicating the host and port on which it is running.\n\n\nEach request, with the following details:\n\n\nTimestamp of the request\n\n\nRemote address of the client making the request\n\n\nRequest method\n\n\nRequest URI\n\n\n\n\nBy default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any [PSR-3 compliant logger][https://www.php-fig.org/psr/psr-3/] to\nlog application details. All logs we emit use \nPsr\\Log\\LogLevel::INFO\n.\n\n\nTo substitute your own logger, you have two options.\n\n\nIf you are manually instantiating a \nZend\\Expressive\\Swoole\\RequestHandlerSwooleRunner\n\ninstance, you may provide it as the sixth argument to the constructor:\n\n\nuse Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner;\n\n$runner = new RequestHandlerSwooleRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $swooleHttpServer,\n    $config,\n    $logger // <-- PSR-3 logger instance\n);\n\n\n\nIf using the provided factory (\nRequestHandlerSwooleRunnerFactory\n) & which\nis the default when using the functionality with Expressive & you can\nprovide the logger via the \nPsr\\Log\\LoggerInterface\n service.",
            "title": "Logging"
        },
        {
            "location": "/logging/#logging",
            "text": "Web servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.  Out-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.  We log two items:   When the web server starts, indicating the host and port on which it is running.  Each request, with the following details:  Timestamp of the request  Remote address of the client making the request  Request method  Request URI   By default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any [PSR-3 compliant logger][https://www.php-fig.org/psr/psr-3/] to\nlog application details. All logs we emit use  Psr\\Log\\LogLevel::INFO .  To substitute your own logger, you have two options.  If you are manually instantiating a  Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner \ninstance, you may provide it as the sixth argument to the constructor:  use Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner;\n\n$runner = new RequestHandlerSwooleRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $swooleHttpServer,\n    $config,\n    $logger // <-- PSR-3 logger instance\n);  If using the provided factory ( RequestHandlerSwooleRunnerFactory ) & which\nis the default when using the functionality with Expressive & you can\nprovide the logger via the  Psr\\Log\\LoggerInterface  service.",
            "title": "Logging"
        },
        {
            "location": "/how_it_works/",
            "text": "How it works\n\n\nWhen you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface, \nwithout using a web server\n.\n\n\nThis sounds a bit strange in PHP, though it will be familiar to \nNode.js\n\ndevelopers; the execution model under Swoole is similar to that technology.\n\n\nThe HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the \non(string $name, callable $action)\n method.\n\n\nThe request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the \non('request')\n\nevent of \nSwoole\\Http\\Server\n. This runner is implemented in the\n\nZend\\Expressive\\Swoole\\RequestHandlerSwooleRunner\n class.\n\n\nThe basic implementation looks similar to the following:\n\n\npublic function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}\n\n\n\nThis package provides a bridge between \nSwoole\\Http\\Request\n (\n$request\n) and\n\nPSR-7\n requests (\n$psr7Request\n;\nspecifically as implemented by \nzend-diactoros\n)\nvia the class \nZend\\Expressive\\Swoole\\ServerRequestSwooleFactory\n.\n\n\nIt also provides a Swoole-specific emitter, \nZend\\Expressive\\Swoole\\SwooleEmitter\n,\nthat converts a PSR-7 response to a \nSwoole\\Http\\Response\n instance.\n\n\nWhen you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4 \nworker\n\n(or \nreactor\n) processes and 1 \nmaster\n process, for a total of 5 PHP processes.\n\n\n\n\nThe advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.\n\n\nPerformance\n\n\nThe ZF developers performed a benchmark running the default \nzend-expressive-skeleton\n\napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.\n\n\nThe results demonstrated that \nExpressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache\n.\n\n\nThis impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.",
            "title": "How it works"
        },
        {
            "location": "/how_it_works/#how-it-works",
            "text": "When you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface,  without using a web server .  This sounds a bit strange in PHP, though it will be familiar to  Node.js \ndevelopers; the execution model under Swoole is similar to that technology.  The HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the  on(string $name, callable $action)  method.  The request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the  on('request') \nevent of  Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\RequestHandlerSwooleRunner  class.  The basic implementation looks similar to the following:  public function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}  This package provides a bridge between  Swoole\\Http\\Request  ( $request ) and PSR-7  requests ( $psr7Request ;\nspecifically as implemented by  zend-diactoros )\nvia the class  Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory .  It also provides a Swoole-specific emitter,  Zend\\Expressive\\Swoole\\SwooleEmitter ,\nthat converts a PSR-7 response to a  Swoole\\Http\\Response  instance.  When you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4  worker \n(or  reactor ) processes and 1  master  process, for a total of 5 PHP processes.   The advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.",
            "title": "How it works"
        },
        {
            "location": "/how_it_works/#performance",
            "text": "The ZF developers performed a benchmark running the default  zend-expressive-skeleton \napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.  The results demonstrated that  Expressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache .  This impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.",
            "title": "Performance"
        }
    ]
}