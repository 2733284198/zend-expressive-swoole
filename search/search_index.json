{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-swoole\n\n\n\n\n\n\nThis library provides the support of \nSwoole\n into\nan \nExpressive\n application. This means you can\nexecute your Expressive application using Swoole directly from the command line.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nConfiguration\n\n\nAfter installing zend-expressive-swoole, you will need to first enable the\ncomponent, and then optionally configure it.\n\n\nWe recommend adding a new configuration file to your autoload directory,\n\nconfig/autoload/swoole.local.php\n. To begin with, use the following contents:\n\n\n<?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), []);\n\n\n\nThe above will setup the Swoole integration for your application.\n\n\nBy default, Swoole executes the HTTP server with host \n127.0.0.1\n on port\n\n8080\n. You can change these values via configuration. Assuming you have the\nabove, modify it to read as follows:\n\n\n<?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => 'insert hostname to use here',\n            'port' => 80, // use an integer value here\n        ],\n    ],\n]);\n\n\n\n\n\nExpressive skeleton 3.1.0 and later\n\n\nIf you have built your application on the 3.1.0 or later version of the\nExpressive skeleton, you do not need to instantiate and invoke the package's\n\nConfigProvider\n, as the skeleton supports it out of the box.\n\n\nYou will only need to provide any additional configuration of the HTTP server.\n\n\n\n\nExecute\n\n\nOnce you have performed the configuration steps as outlined above, you can run\nan Expressive application with Swoole using the following command:\n\n\nphp public/index.php start\n\n\n\nDocumentation\n\n\nBrowse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/\n\n\nSupport\n\n\n\n\nIssues\n\n\nChat\n\n\nForum",
            "title": "zend-expressive-swoole"
        },
        {
            "location": "/#zend-expressive-swoole",
            "text": "This library provides the support of  Swoole  into\nan  Expressive  application. This means you can\nexecute your Expressive application using Swoole directly from the command line.",
            "title": "zend-expressive-swoole"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-swoole",
            "title": "Installation"
        },
        {
            "location": "/#configuration",
            "text": "After installing zend-expressive-swoole, you will need to first enable the\ncomponent, and then optionally configure it.  We recommend adding a new configuration file to your autoload directory, config/autoload/swoole.local.php . To begin with, use the following contents:  <?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), []);  The above will setup the Swoole integration for your application.  By default, Swoole executes the HTTP server with host  127.0.0.1  on port 8080 . You can change these values via configuration. Assuming you have the\nabove, modify it to read as follows:  <?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => 'insert hostname to use here',\n            'port' => 80, // use an integer value here\n        ],\n    ],\n]);",
            "title": "Configuration"
        },
        {
            "location": "/#expressive-skeleton-310-and-later",
            "text": "If you have built your application on the 3.1.0 or later version of the\nExpressive skeleton, you do not need to instantiate and invoke the package's ConfigProvider , as the skeleton supports it out of the box.  You will only need to provide any additional configuration of the HTTP server.",
            "title": "Expressive skeleton 3.1.0 and later"
        },
        {
            "location": "/#execute",
            "text": "Once you have performed the configuration steps as outlined above, you can run\nan Expressive application with Swoole using the following command:  php public/index.php start",
            "title": "Execute"
        },
        {
            "location": "/#documentation",
            "text": "Browse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/",
            "title": "Documentation"
        },
        {
            "location": "/#support",
            "text": "Issues  Chat  Forum",
            "title": "Support"
        },
        {
            "location": "/intro/",
            "text": "Swoole\n\n\nSwoole\n is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.\n\n\nInstall swoole\n\n\nYou can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:\n\n\n$ pecl install swoole\n\n\n\nFor more information on the extension, \nvisit its package details on PECL\n.\n\n\nInstall zend-expressive-swoole\n\n\nTo install this package, use \nComposer\n:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nSwoole with Expressive\n\n\nzend-expressive-swoole enables an Expressive application to be executed with\nthe \nSwoole\n extension. This means you can run the\napplication from the command line, \nwithout requiring a web server\n.\n\n\nYou can run the application using the following command:\n\n\n$ php public/index.php\n\n\n\nThis command will execute Swoole on \nlocalhost\n via port \n8080\n.\n\n\n\n\nExpressive skeleton versions prior to 3.1.0\n\n\nThe above will work immediately after installing zend-expressive-swoole if you\nare using a version of \nzend-expressive-skeleton\n\nfrom 3.1.0 or later.\n\n\nFor applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as \nconfig/autoload/zend-expressive-swoole.global.php\n\nor \nconfig/autoload/zend-expressive-swoole.local.php\n with the following\ncontents:\n\n\n<?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();\n\n\n\n\n\nYou can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:\n\n\n// In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];\n\n\n\nProviding additional Swoole configuration\n\n\nYou can also configure the Swoole HTTP server using an \noptions\n key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:\n\n\n// config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE,\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL,\n            'options' => [\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n            ],\n        ],\n    ],\n];\n\n\n\nServing static files\n\n\nWe support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant \nZend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\nOur static resource capabilities are fairly comprehensive; please see the\n\nchapter on static resources\n for full details on\nconfiguration.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#swoole",
            "text": "Swoole  is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.",
            "title": "Swoole"
        },
        {
            "location": "/intro/#install-swoole",
            "text": "You can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:  $ pecl install swoole  For more information on the extension,  visit its package details on PECL .",
            "title": "Install swoole"
        },
        {
            "location": "/intro/#install-zend-expressive-swoole",
            "text": "To install this package, use  Composer :  $ composer require zendframework/zend-expressive-swoole",
            "title": "Install zend-expressive-swoole"
        },
        {
            "location": "/intro/#swoole-with-expressive",
            "text": "zend-expressive-swoole enables an Expressive application to be executed with\nthe  Swoole  extension. This means you can run the\napplication from the command line,  without requiring a web server .  You can run the application using the following command:  $ php public/index.php  This command will execute Swoole on  localhost  via port  8080 .",
            "title": "Swoole with Expressive"
        },
        {
            "location": "/intro/#expressive-skeleton-versions-prior-to-310",
            "text": "The above will work immediately after installing zend-expressive-swoole if you\nare using a version of  zend-expressive-skeleton \nfrom 3.1.0 or later.  For applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as  config/autoload/zend-expressive-swoole.global.php \nor  config/autoload/zend-expressive-swoole.local.php  with the following\ncontents:  <?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();   You can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:  // In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];",
            "title": "Expressive skeleton versions prior to 3.1.0"
        },
        {
            "location": "/intro/#providing-additional-swoole-configuration",
            "text": "You can also configure the Swoole HTTP server using an  options  key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:  // config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE,\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL,\n            'options' => [\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n            ],\n        ],\n    ],\n];",
            "title": "Providing additional Swoole configuration"
        },
        {
            "location": "/intro/#serving-static-files",
            "text": "We support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant  Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .\nOur static resource capabilities are fairly comprehensive; please see the chapter on static resources  for full details on\nconfiguration.",
            "title": "Serving static files"
        },
        {
            "location": "/static-resources/",
            "text": "Static Resources\n\n\nOne feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.\n\n\nTo enable this, the package provides an alternate\n\nRequestHandlerRunner\n\nimplementation via the class \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n\nthat performs two duties:\n\n\n\n\nIf a static resource is matched, it serves that.\n\n\nOtherwise, it passes off handling to the composed application pipeline.\n\n\n\n\nInternally, the \nSwooleRequestHandlerRunner\n composes another class, a \n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n instance. This instance\nis passed the Swoole request and response, and returns a value indicating\nwhether or not it was able to identify and serve a matching static resource.\n\n\nOur default implementation, \nZend\\Expressive\\Swoole\\StaticResourceHandler\n,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.\n\n\nMiddleware\n\n\nThe \nStaticResourceHandler\n implementation performs its work by composing a\nqueue of middleware to execute when attempting to serve a matched file. Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:\n\n\n\n\n\n\nCacheControlMiddleware\n will set a \nCache-Control\n header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the \nCache-Control\n directive to\n  use when the match occurs.\n\n\n\n\n\n\nClearStatCacheMiddleware\n will, if configured to do so, call\n  \nclearstatcache()\n either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.\n\n\n\n\n\n\nContentTypeFilterMiddleware\n checks the incoming filename against a map of\n  known extensions and their associated Content-Type values. If it cannot\n  match the file, it returns a value indicating no match was found so that the\n  application can continue processing the request. Otherwise, it provides the\n  Content-Type for the associated response. This middleware is generally best\n  used as the outermost layer, to ensure no other middleware executes in the\n  case that the file cannot be matched.\n\n\n\n\n\n\nETagMiddleware\n will set an \nETag\n header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the \nETag\n\n  header value matches either an \nIf-Match\n or \nIf-None-Match\n request header,\n  it will provide a response status of \n304\n and disable sending content.\n\n\n\n\n\n\nGzipMiddleware\n detects the \nAccept-Encoding\n request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.\n\n\n\n\n\n\nHeadMiddleware\n will force an empty response. (The status and headers may be\n  set by other middleware.)\n\n\n\n\n\n\nLastModifiedMiddleware\n will set a \nLast-Modified\n header using the\n  \nfilemtime()\n value of the requested resource. If the header value is later\n  than an \nIf-Modified-Since\n  request header, it will provide a response status\n  of \n304\n and disable sending content.\n\n\n\n\n\n\nMethodNotAllowedMiddleware\n will set the response status to \n405\n, and set an\n  \nAllow\n header indicating the allowed methods when an unsupported request\n  method is provided.\n\n\n\n\n\n\nOptionsMiddleware\n will force an empty response with an \nAllow\n header set\n  to the allowed methods. (Other headers may also be present!)\n\n\n\n\n\n\nBy default, these are registered in the following order, contingent on\nconfiguration being provided:\n\n\n\n\nContentTypeFilterMiddleware\n\n\nMethodNotAllowedMiddleware\n\n\nOptionsMiddleware\n\n\nHeadMiddleware\n\n\nGzipMiddleware\n\n\nClearStatCacheMiddleware\n\n\nCacheControlMiddleware\n\n\nLastModifiedMiddleware\n\n\nETagMiddleware\n\n\n\n\nThis approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the \nLast-Modified\n or \nETag\n headers); it also\nensures that all possible headers are provided whenever possible (e.g., a \nHEAD\n\nrequest should also expose \nCache-Control\n, \nLast-Modified\n, and \nETag\n\nheaders).\n\n\n\n\nProviding your own middleware\n\n\nIf you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate\n\nStaticResourceHandler\n factory. In most cases, you can extend\n\nStaticResourceHandlerFactory\n and override the \nconfigureMiddleware(array\n$config) : array\n method to do so. Be sure to remember to add a \ndependencies\n\nsetting mapping the \nStaticResourceHandlerInterface\n service to your new factory\nwhen done!\n\n\n\n\nConfiguration\n\n\nWe provide a factory for the \nStaticResourceHandler\n that uses a\nconfiguration-driven approach in order to:\n\n\n\n\nSet the document root.\n\n\nSet the map of allowed extensions to content-types.\n\n\nConfigure and provide middleware.\n\n\n\n\nThe following demonstrates all currently available configuration options:\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nSecurity warning\n\n\nNever add \nphp\n as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!\n\n\nDocument root\n\n\nIf no \ndocument_root\n configuration is present, the default is to use\n\ngetcwd() . '/public'\n. If either the configured or default document root\ndoes not exist, we raise an exception.\n\n\nDefault extension/content-types\n\n\nBy default, we serve files with extensions in the whitelist defined in the\nconstant \nZend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\n\n\n\n\nConfiguration Example\n\n\nThe example which follows provides the following options:\n\n\n\n\nSets the document root to \n/var/www/htdocs\n.\n\n\nAdds a custom extension / content-type map.\n\n\nProvides a clearstatcache interval of 2 hours.\n\n\nSelects the \"strong\" ETag algorithm.\n\n\nIndicates a gzip compression level of 3.\n\n\nSets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.\n\n\nSets Cache-Control directives for plain text files.\n\n\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nWriting Middleware\n\n\nStatic resource middleware must implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface\n, which\ndefines the following:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}\n\n\n\nThe \n$next\n argument has the following signature:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;\n\n\n\nTypically, middleware will look something like this:\n\n\n$response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.\n\n\n\nMiddleware either produces or manipulates a\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse\n instance.\nThat class looks like the following:\n\n\nclass StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * Call this method to indicate that the request cannot be served as a\n     * static resource. The request runner will then proceed to execute\n     * the associated application in order to generate the response.\n     */\n    public function markAsFailure() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    /**\n     * Use this within a response content callback to set the associated\n     * Content-Length of the generated response. Loggers can then query\n     * for this information in order to provide that information in the logs.\n     */\n    public function setContentLength(int $length) : void;\n\n    public function setStatus(int $status) : void;\n}\n\n\n\nMost middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via \ndisableContent()\n).\nMiddleware that restricts access or filters out specific files will also use\n\nmarkAsFailure()\n.\n\n\n\n\nProviding an alternative mechanism for sending response content\n\n\nIn some cases, you may want to alter how the \nSwoole\\Http\\Response\n receives the\nbody content. By default, we use \nSwoole\\Http\\Response::sendfile()\n. However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the \nGzipMiddleware\n adds a compression filter to\na filehandle representing the file to send, and then calls\n\nSwoole\\Http\\Response::write()\n in a loop until all content is sent.\n\n\nTo perform work like this, you can call the\n\nStaticResourceResponse::setResponseContentCallback()\n method as detailed in the\nsection above within your middleware.\n\n\n\n\nAlternative static resource handlers\n\n\nAs noted at the beginning of this chapter, the \nSwooleRequestHandlerRunner\n\ncomposes a \nStaticResourceHandlerInterface\n instance in order to determine if a\nresource was matched by the request, and then to serve it.\n\n\nIf you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n:\n\n\ndeclare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Attempt to process a static resource based on the current request.\n     *\n     * If the resource cannot be processed, the method should return null.\n     * Otherwise, it should return the StaticResourceResponse that was used\n     * to send the Swoole response instance. The runner can then query this\n     * for content length and status.\n     */\n    public function processStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : ?StaticResourceHandler\\StaticResourceResponse;\n}\n\n\n\nOnce implemented, map the service\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n to a factory that\nreturns your custom implementation within your \ndependencies\n configuration.",
            "title": "Static Resources"
        },
        {
            "location": "/static-resources/#static-resources",
            "text": "One feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.  To enable this, the package provides an alternate RequestHandlerRunner \nimplementation via the class  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner \nthat performs two duties:   If a static resource is matched, it serves that.  Otherwise, it passes off handling to the composed application pipeline.   Internally, the  SwooleRequestHandlerRunner  composes another class, a  Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  instance. This instance\nis passed the Swoole request and response, and returns a value indicating\nwhether or not it was able to identify and serve a matching static resource.  Our default implementation,  Zend\\Expressive\\Swoole\\StaticResourceHandler ,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.",
            "title": "Static Resources"
        },
        {
            "location": "/static-resources/#middleware",
            "text": "The  StaticResourceHandler  implementation performs its work by composing a\nqueue of middleware to execute when attempting to serve a matched file. Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:    CacheControlMiddleware  will set a  Cache-Control  header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the  Cache-Control  directive to\n  use when the match occurs.    ClearStatCacheMiddleware  will, if configured to do so, call\n   clearstatcache()  either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.    ContentTypeFilterMiddleware  checks the incoming filename against a map of\n  known extensions and their associated Content-Type values. If it cannot\n  match the file, it returns a value indicating no match was found so that the\n  application can continue processing the request. Otherwise, it provides the\n  Content-Type for the associated response. This middleware is generally best\n  used as the outermost layer, to ensure no other middleware executes in the\n  case that the file cannot be matched.    ETagMiddleware  will set an  ETag  header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the  ETag \n  header value matches either an  If-Match  or  If-None-Match  request header,\n  it will provide a response status of  304  and disable sending content.    GzipMiddleware  detects the  Accept-Encoding  request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.    HeadMiddleware  will force an empty response. (The status and headers may be\n  set by other middleware.)    LastModifiedMiddleware  will set a  Last-Modified  header using the\n   filemtime()  value of the requested resource. If the header value is later\n  than an  If-Modified-Since   request header, it will provide a response status\n  of  304  and disable sending content.    MethodNotAllowedMiddleware  will set the response status to  405 , and set an\n   Allow  header indicating the allowed methods when an unsupported request\n  method is provided.    OptionsMiddleware  will force an empty response with an  Allow  header set\n  to the allowed methods. (Other headers may also be present!)    By default, these are registered in the following order, contingent on\nconfiguration being provided:   ContentTypeFilterMiddleware  MethodNotAllowedMiddleware  OptionsMiddleware  HeadMiddleware  GzipMiddleware  ClearStatCacheMiddleware  CacheControlMiddleware  LastModifiedMiddleware  ETagMiddleware   This approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the  Last-Modified  or  ETag  headers); it also\nensures that all possible headers are provided whenever possible (e.g., a  HEAD \nrequest should also expose  Cache-Control ,  Last-Modified , and  ETag \nheaders).",
            "title": "Middleware"
        },
        {
            "location": "/static-resources/#providing-your-own-middleware",
            "text": "If you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate StaticResourceHandler  factory. In most cases, you can extend StaticResourceHandlerFactory  and override the  configureMiddleware(array\n$config) : array  method to do so. Be sure to remember to add a  dependencies \nsetting mapping the  StaticResourceHandlerInterface  service to your new factory\nwhen done!",
            "title": "Providing your own middleware"
        },
        {
            "location": "/static-resources/#configuration",
            "text": "We provide a factory for the  StaticResourceHandler  that uses a\nconfiguration-driven approach in order to:   Set the document root.  Set the map of allowed extensions to content-types.  Configure and provide middleware.   The following demonstrates all currently available configuration options:  // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/static-resources/#security-warning",
            "text": "Never add  php  as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!",
            "title": "Security warning"
        },
        {
            "location": "/static-resources/#document-root",
            "text": "If no  document_root  configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root\ndoes not exist, we raise an exception.",
            "title": "Document root"
        },
        {
            "location": "/static-resources/#default-extensioncontent-types",
            "text": "By default, we serve files with extensions in the whitelist defined in the\nconstant  Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .",
            "title": "Default extension/content-types"
        },
        {
            "location": "/static-resources/#configuration-example",
            "text": "The example which follows provides the following options:   Sets the document root to  /var/www/htdocs .  Adds a custom extension / content-type map.  Provides a clearstatcache interval of 2 hours.  Selects the \"strong\" ETag algorithm.  Indicates a gzip compression level of 3.  Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.  Sets Cache-Control directives for plain text files.   // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration Example"
        },
        {
            "location": "/static-resources/#writing-middleware",
            "text": "Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which\ndefines the following:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}  The  $next  argument has the following signature:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;  Typically, middleware will look something like this:  $response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.  Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse  instance.\nThat class looks like the following:  class StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * Call this method to indicate that the request cannot be served as a\n     * static resource. The request runner will then proceed to execute\n     * the associated application in order to generate the response.\n     */\n    public function markAsFailure() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    /**\n     * Use this within a response content callback to set the associated\n     * Content-Length of the generated response. Loggers can then query\n     * for this information in order to provide that information in the logs.\n     */\n    public function setContentLength(int $length) : void;\n\n    public function setStatus(int $status) : void;\n}  Most middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via  disableContent() ).\nMiddleware that restricts access or filters out specific files will also use markAsFailure() .",
            "title": "Writing Middleware"
        },
        {
            "location": "/static-resources/#providing-an-alternative-mechanism-for-sending-response-content",
            "text": "In some cases, you may want to alter how the  Swoole\\Http\\Response  receives the\nbody content. By default, we use  Swoole\\Http\\Response::sendfile() . However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the  GzipMiddleware  adds a compression filter to\na filehandle representing the file to send, and then calls Swoole\\Http\\Response::write()  in a loop until all content is sent.  To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback()  method as detailed in the\nsection above within your middleware.",
            "title": "Providing an alternative mechanism for sending response content"
        },
        {
            "location": "/static-resources/#alternative-static-resource-handlers",
            "text": "As noted at the beginning of this chapter, the  SwooleRequestHandlerRunner \ncomposes a  StaticResourceHandlerInterface  instance in order to determine if a\nresource was matched by the request, and then to serve it.  If you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface :  declare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Attempt to process a static resource based on the current request.\n     *\n     * If the resource cannot be processed, the method should return null.\n     * Otherwise, it should return the StaticResourceResponse that was used\n     * to send the Swoole response instance. The runner can then query this\n     * for content length and status.\n     */\n    public function processStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : ?StaticResourceHandler\\StaticResourceResponse;\n}  Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  to a factory that\nreturns your custom implementation within your  dependencies  configuration.",
            "title": "Alternative static resource handlers"
        },
        {
            "location": "/logging/",
            "text": "Logging\n\n\nWeb servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.\n\n\nOut-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.\n\n\nWe log a number of items:\n\n\n\n\nWhen the web server starts, indicating the host and port on which it is running.\n\n\nWhen workers start, including the working directory and worker ID.\n\n\nWhen the web server stops.\n\n\nWhen the web server reloads workers.\n\n\nEach request (more on this below)\n\n\n\n\nBy default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any \nPSR-3 compliant logger\n to\nlog application details. We emit logs detailing server operations using the\npriority \nPsr\\Log\\LogLevel::NOTICE\n (unless detailing an error, such as\ninability to reload)), while \nPsr\\Log\\LogLevel::INFO\n and \nPsr\\Log\\LogLevel::ERROR\n\nare used to log requests (errors are used for response statuses greater than or\nequal to 400).\n\n\nAccess Logs\n\n\nTechnically, the \nSwooleRequestHandlerRunner\n doesn't use PSR-3 loggers\ndirectly, but, rather, instances of \nZend\\Expressive\\Swoole\\Log\\AccessLogInterface\n.\nThis package-specific interface extends the PSR-3 interface to add two methods:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Request;\nuse Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse;\n\ninterface AccessLogInterface extends LoggerInterface\n{\n    public function logAccessForStaticResource(\n        Request $request,\n        StaticResourceResponse $response\n    ) : void;\n\n    public function logAccessForPsr7Resource(\n        Request $request,\n        ResponseInterface $response\n    ) : void;\n}\n\n\n\nTo allow usage of a standard PSR-3 logger, we also provide a decorator,\n\nZend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator\n, which decorates the PSR-3\nlogger and provides a standard implementation for the two methods listed above.\nIf you have defined a PSR-3 \nLoggerInterface\n service in your application, it\nwill be used automatically.\n\n\nFormatting logs\n\n\nThe Apache web server has long provided flexible and robust logging\ncapabilities, and its formats are used across a variety of web servers and\nlogging platforms. As such, we have chosen to use its formats for our standard\nimplementation. However, we allow you to plug in your own system as needed.\n\n\nYou can refer to the \nApache mod_log_config documentation\n\nin order to understand the available placeholders available for format strings.\n\n\nFormatting is provided to the \nPsr3AccessLogDecorator\n via instances of the\ninterface \nZend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface\n:\n\n\ninterface AccessLogFormatterInterface\n{\n    public function format(AccessLogDataMap $map) : string;\n}\n\n\n\nAccessLogDataMap\n is a class used internally by the \nPsr3AccessLogDecorator\n in\norder to map Apache log placeholders to request/response values.\n\n\nOur default \nAccessLogFormatterInterface\n implementation, \nAccessLogFormatter\n,\nprovides constants referencing the most common formats, but also allows you to\nuse arbitrary log formats that use the standard Apache placeholders. The formats\nwe include by default are:\n\n\n\n\nAccessLogFormatter::FORMAT_COMMON\n: Apache common log format: \n%h %l %u %t \"%r\" %>s %b\n\n\nAccessLogFormatter::FORMAT_COMMON_VHOST\n: Apache common log format + vhost: \n%v %h %l %u %t \"%r\" %>s %b\n\n\nAccessLogFormatter::FORMAT_COMBINED\n: Apache combined log format: \n%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"\n\n\nAccessLogFormatter::FORMAT_REFERER\n: \n%{Referer}i -> %U\n\n\nAccessLogFormatter::FORMAT_AGENT\n: \n%{User-Agent}i\n\n\nAccessLogFormatter::FORMAT_VHOST\n: Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b';\n\n\nAccessLogFormatter::FORMAT_COMMON_DEBIAN\n: Debian variant of common log format: \n%h %l %u %t \u201c%r\u201d %>s %O\n;\n\n\nAccessLogFormatter::FORMAT_COMBINED_DEBIAN\n: Debian variant of combined log format: \n%h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d\n;\n\n\nAccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN\n: Debian variant of combined log format + vhost: \n%v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\"\n;\n\n\n\n\nConfiguring a logger\n\n\nYou may subsitute your own logger implementation into the Swoole request handler\nrunner.\n\n\nManual usage\n\n\nIf you are manually instantiating a \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n\ninstance, you may provide it as the seventh argument to the constructor:\n\n\nuse Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner;\n\n$runner = new SwooleRequestHandlerRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $pidManager,\n    $serverFactory,\n    $staticResourceHandler,\n    $logger // <-- AccessLoggerInterface instance\n);\n\n\n\nContainer usage\n\n\nIf you are using a \nPSR-11\n container, the\n\nSwooleRequestHandlerRunnerFactory\n will retrieve a log instance using the\n\nZend\\Expressive\\Swoole\\Log\\AccessLogInterface\n service.\n\n\nYou have two options for substituting your own logger from there.\n\n\nFirst, you can create your own factory that produces an \nAccessLogInterface\n\ninstance, and map it to the service. This is the best route if you want to write\nyour own implementation, or want to use a different PSR-3 logger service.\n\n\nIf you are okay with re-using your existing PSR-3 logger, the provided\n\nZend\\Expressive\\Swoole\\Log\\AccessLogFactory\n will use the\n\nPsr\\Log\\LoggerInterface\n service to create a \nPsr3AccessLogDecorator\n instance.\n\n\nThis factory also allows you to specify a custom \nAccessLogFormatterInterface\n\ninstance if you want. It will look up a service by the fully-qualified interface\nname, and use it if present. Otherwise, it creates an \nAccessLogFormatter\n\ninstance for you.\n\n\nThe factory will also look at the following configuration values:\n\n\n'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'format' => string, // one of the AccessLogFormatter::FORMAT_*\n                                // constants, or a custom format string\n            'use-hostname-lookups' => bool, // Set to true to enable hostname lookups\n        ],\n    ],\n],",
            "title": "Logging"
        },
        {
            "location": "/logging/#logging",
            "text": "Web servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.  Out-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.  We log a number of items:   When the web server starts, indicating the host and port on which it is running.  When workers start, including the working directory and worker ID.  When the web server stops.  When the web server reloads workers.  Each request (more on this below)   By default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any  PSR-3 compliant logger  to\nlog application details. We emit logs detailing server operations using the\npriority  Psr\\Log\\LogLevel::NOTICE  (unless detailing an error, such as\ninability to reload)), while  Psr\\Log\\LogLevel::INFO  and  Psr\\Log\\LogLevel::ERROR \nare used to log requests (errors are used for response statuses greater than or\nequal to 400).",
            "title": "Logging"
        },
        {
            "location": "/logging/#access-logs",
            "text": "Technically, the  SwooleRequestHandlerRunner  doesn't use PSR-3 loggers\ndirectly, but, rather, instances of  Zend\\Expressive\\Swoole\\Log\\AccessLogInterface .\nThis package-specific interface extends the PSR-3 interface to add two methods:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Request;\nuse Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse;\n\ninterface AccessLogInterface extends LoggerInterface\n{\n    public function logAccessForStaticResource(\n        Request $request,\n        StaticResourceResponse $response\n    ) : void;\n\n    public function logAccessForPsr7Resource(\n        Request $request,\n        ResponseInterface $response\n    ) : void;\n}  To allow usage of a standard PSR-3 logger, we also provide a decorator, Zend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3\nlogger and provides a standard implementation for the two methods listed above.\nIf you have defined a PSR-3  LoggerInterface  service in your application, it\nwill be used automatically.",
            "title": "Access Logs"
        },
        {
            "location": "/logging/#formatting-logs",
            "text": "The Apache web server has long provided flexible and robust logging\ncapabilities, and its formats are used across a variety of web servers and\nlogging platforms. As such, we have chosen to use its formats for our standard\nimplementation. However, we allow you to plug in your own system as needed.  You can refer to the  Apache mod_log_config documentation \nin order to understand the available placeholders available for format strings.  Formatting is provided to the  Psr3AccessLogDecorator  via instances of the\ninterface  Zend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface :  interface AccessLogFormatterInterface\n{\n    public function format(AccessLogDataMap $map) : string;\n}  AccessLogDataMap  is a class used internally by the  Psr3AccessLogDecorator  in\norder to map Apache log placeholders to request/response values.  Our default  AccessLogFormatterInterface  implementation,  AccessLogFormatter ,\nprovides constants referencing the most common formats, but also allows you to\nuse arbitrary log formats that use the standard Apache placeholders. The formats\nwe include by default are:   AccessLogFormatter::FORMAT_COMMON : Apache common log format:  %h %l %u %t \"%r\" %>s %b  AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost:  %v %h %l %u %t \"%r\" %>s %b  AccessLogFormatter::FORMAT_COMBINED : Apache combined log format:  %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"  AccessLogFormatter::FORMAT_REFERER :  %{Referer}i -> %U  AccessLogFormatter::FORMAT_AGENT :  %{User-Agent}i  AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b';  AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format:  %h %l %u %t \u201c%r\u201d %>s %O ;  AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format:  %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d ;  AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost:  %v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\" ;",
            "title": "Formatting logs"
        },
        {
            "location": "/logging/#configuring-a-logger",
            "text": "You may subsitute your own logger implementation into the Swoole request handler\nrunner.",
            "title": "Configuring a logger"
        },
        {
            "location": "/logging/#manual-usage",
            "text": "If you are manually instantiating a  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner \ninstance, you may provide it as the seventh argument to the constructor:  use Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner;\n\n$runner = new SwooleRequestHandlerRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $pidManager,\n    $serverFactory,\n    $staticResourceHandler,\n    $logger // <-- AccessLoggerInterface instance\n);",
            "title": "Manual usage"
        },
        {
            "location": "/logging/#container-usage",
            "text": "If you are using a  PSR-11  container, the SwooleRequestHandlerRunnerFactory  will retrieve a log instance using the Zend\\Expressive\\Swoole\\Log\\AccessLogInterface  service.  You have two options for substituting your own logger from there.  First, you can create your own factory that produces an  AccessLogInterface \ninstance, and map it to the service. This is the best route if you want to write\nyour own implementation, or want to use a different PSR-3 logger service.  If you are okay with re-using your existing PSR-3 logger, the provided Zend\\Expressive\\Swoole\\Log\\AccessLogFactory  will use the Psr\\Log\\LoggerInterface  service to create a  Psr3AccessLogDecorator  instance.  This factory also allows you to specify a custom  AccessLogFormatterInterface \ninstance if you want. It will look up a service by the fully-qualified interface\nname, and use it if present. Otherwise, it creates an  AccessLogFormatter \ninstance for you.  The factory will also look at the following configuration values:  'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'format' => string, // one of the AccessLogFormatter::FORMAT_*\n                                // constants, or a custom format string\n            'use-hostname-lookups' => bool, // Set to true to enable hostname lookups\n        ],\n    ],\n],",
            "title": "Container usage"
        },
        {
            "location": "/how_it_works/",
            "text": "How it works\n\n\nWhen you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface, \nwithout using a web server\n.\n\n\nThis sounds a bit strange in PHP, though it will be familiar to \nNode.js\n\ndevelopers; the execution model under Swoole is similar to that technology.\n\n\nThe HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the \non(string $name, callable $action)\n method.\n\n\nThe request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the \non('request')\n\nevent of \nSwoole\\Http\\Server\n. This runner is implemented in the\n\nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n class.\n\n\nThe basic implementation looks similar to the following:\n\n\npublic function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}\n\n\n\nThis package provides a bridge between \nSwoole\\Http\\Request\n (\n$request\n) and\n\nPSR-7\n requests (\n$psr7Request\n;\nspecifically as implemented by \nzend-diactoros\n)\nvia the class \nZend\\Expressive\\Swoole\\ServerRequestSwooleFactory\n.\n\n\nIt also provides a Swoole-specific emitter, \nZend\\Expressive\\Swoole\\SwooleEmitter\n,\nthat converts a PSR-7 response to a \nSwoole\\Http\\Response\n instance.\n\n\nWhen you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4 \nworker\n\n(or \nreactor\n) processes and 1 \nmaster\n process, for a total of 5 PHP processes.\n\n\n\n\nThe advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.\n\n\nPerformance\n\n\nThe ZF developers performed a benchmark running the default \nzend-expressive-skeleton\n\napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.\n\n\nThe results demonstrated that \nExpressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache\n.\n\n\nThis impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.",
            "title": "How it works"
        },
        {
            "location": "/how_it_works/#how-it-works",
            "text": "When you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface,  without using a web server .  This sounds a bit strange in PHP, though it will be familiar to  Node.js \ndevelopers; the execution model under Swoole is similar to that technology.  The HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the  on(string $name, callable $action)  method.  The request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the  on('request') \nevent of  Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner  class.  The basic implementation looks similar to the following:  public function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}  This package provides a bridge between  Swoole\\Http\\Request  ( $request ) and PSR-7  requests ( $psr7Request ;\nspecifically as implemented by  zend-diactoros )\nvia the class  Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory .  It also provides a Swoole-specific emitter,  Zend\\Expressive\\Swoole\\SwooleEmitter ,\nthat converts a PSR-7 response to a  Swoole\\Http\\Response  instance.  When you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4  worker \n(or  reactor ) processes and 1  master  process, for a total of 5 PHP processes.   The advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.",
            "title": "How it works"
        },
        {
            "location": "/how_it_works/#performance",
            "text": "The ZF developers performed a benchmark running the default  zend-expressive-skeleton \napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.  The results demonstrated that  Expressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache .  This impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.",
            "title": "Performance"
        }
    ]
}