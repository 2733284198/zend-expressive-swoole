{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-swoole\n\n\n\n\n\n\nThis library provides the support of \nSwoole\n into\nan \nExpressive\n application. This means you can\nexecute your Expressive application using Swoole directly from the command line.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nConfiguration\n\n\nAfter installing zend-expressive-swoole, you will need to first enable the\ncomponent, and then optionally configure it.\n\n\nWe recommend adding a new configuration file to your autoload directory,\n\nconfig/autoload/swoole.local.php\n. To begin with, use the following contents:\n\n\n<?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), []);\n\n\n\nThe above will setup the Swoole integration for your application.\n\n\nBy default, Swoole executes the HTTP server with host \n127.0.0.1\n on port\n\n8080\n. You can change these values via configuration. Assuming you have the\nabove, modify it to read as follows:\n\n\n<?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => 'insert hostname to use here',\n            'port' => 80, // use an integer value here\n        ],\n    ],\n]);\n\n\n\n\n\nExpressive skeleton 3.1.0 and later\n\n\nIf you have built your application on the 3.1.0 or later version of the\nExpressive skeleton, you do not need to instantiate and invoke the package's\n\nConfigProvider\n, as the skeleton supports it out of the box.\n\n\nYou will only need to provide any additional configuration of the HTTP server.\n\n\n\n\nExecute\n\n\nOnce you have performed the configuration steps as outlined above, you can run\nan Expressive application with Swoole using the following command:\n\n\n$ ./vendor/bin/zend-expressive-swoole start\n\n\n\nCall the command without arguments to get a list of available commands, and use\nthe \nhelp\n meta-argument to get help on individual commands:\n\n\n$ ./vendor/bin/zend-expressive-swoole help start\n\n\n\nDocumentation\n\n\nBrowse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/\n\n\nSupport\n\n\n\n\nIssues\n\n\nChat\n\n\nForum",
            "title": "Home"
        },
        {
            "location": "/#zend-expressive-swoole",
            "text": "This library provides the support of  Swoole  into\nan  Expressive  application. This means you can\nexecute your Expressive application using Swoole directly from the command line.",
            "title": "zend-expressive-swoole"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-swoole",
            "title": "Installation"
        },
        {
            "location": "/#configuration",
            "text": "After installing zend-expressive-swoole, you will need to first enable the\ncomponent, and then optionally configure it.  We recommend adding a new configuration file to your autoload directory, config/autoload/swoole.local.php . To begin with, use the following contents:  <?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), []);  The above will setup the Swoole integration for your application.  By default, Swoole executes the HTTP server with host  127.0.0.1  on port 8080 . You can change these values via configuration. Assuming you have the\nabove, modify it to read as follows:  <?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => 'insert hostname to use here',\n            'port' => 80, // use an integer value here\n        ],\n    ],\n]);",
            "title": "Configuration"
        },
        {
            "location": "/#expressive-skeleton-310-and-later",
            "text": "If you have built your application on the 3.1.0 or later version of the\nExpressive skeleton, you do not need to instantiate and invoke the package's ConfigProvider , as the skeleton supports it out of the box.  You will only need to provide any additional configuration of the HTTP server.",
            "title": "Expressive skeleton 3.1.0 and later"
        },
        {
            "location": "/#execute",
            "text": "Once you have performed the configuration steps as outlined above, you can run\nan Expressive application with Swoole using the following command:  $ ./vendor/bin/zend-expressive-swoole start  Call the command without arguments to get a list of available commands, and use\nthe  help  meta-argument to get help on individual commands:  $ ./vendor/bin/zend-expressive-swoole help start",
            "title": "Execute"
        },
        {
            "location": "/#documentation",
            "text": "Browse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/",
            "title": "Documentation"
        },
        {
            "location": "/#support",
            "text": "Issues  Chat  Forum",
            "title": "Support"
        },
        {
            "location": "/v2/intro/",
            "text": "Swoole\n\n\nSwoole\n is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.\n\n\nInstall swoole\n\n\nYou can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:\n\n\n$ pecl install swoole\n\n\n\nFor more information on the extension, \nvisit its package details on PECL\n.\n\n\nInstall zend-expressive-swoole\n\n\nTo install this package, use \nComposer\n:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nSwoole with Expressive\n\n\nzend-expressive-swoole enables an Expressive application to be executed with\nthe \nSwoole\n extension. This means you can run the\napplication from the command line, \nwithout requiring a web server\n.\n\n\nYou can run the application using the following command:\n\n\n$ ./vendor/bin/zend-expressive-swoole start\n\n\n\nThis command will execute Swoole on \nlocalhost\n via port \n8080\n.\n\n\n\n\nOther commands\n\n\nTo get a list of all available commands, run the command without arguments:\n\n\n$ ./vendor/bin/zend-expressive-swoole\n\n\n\nIf you add the argument \nhelp\n before any command name, the tooling will\nprovide you with more detailed information on that command.\n\n\nExpressive skeleton versions prior to 3.1.0\n\n\nThe above will work immediately after installing zend-expressive-swoole if you\nare using a version of \nzend-expressive-skeleton\n\nfrom 3.1.0 or later.\n\n\nFor applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as \nconfig/autoload/zend-expressive-swoole.global.php\n\nor \nconfig/autoload/zend-expressive-swoole.local.php\n with the following\ncontents:\n\n\n<?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();\n\n\n\n\n\nYou can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:\n\n\n// In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];\n\n\n\nProviding additional Swoole configuration\n\n\nYou can also configure the Swoole HTTP server using an \noptions\n key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:\n\n\n// config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        // Available in Swoole 4.1 and up; enables coroutine support\n        // for most I/O operations:\n        'enable_coroutine' => true,\n\n        // Configure Swoole HTTP Server:\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS;\n                                   // SWOOLE_BASE is the default\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server\n            'options' => [\n                // Set the SSL certificate and key paths for SSL support:\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n                // Whether or not the HTTP server should use coroutines;\n                // enabled by default, and generally should not be disabled:\n                'enable_coroutine' => true,\n\n                // Overwrite the default location of the pid file;\n                // required when you want to run multiple instances of your service in different ports:\n                'pid_file' => 'path/to/pid_file.pid',\n            ],\n\n            // Since 2.1.0: Set the process name prefix.\n            // The master process will be named `{prefix}-master`,\n            // worker processes will be named `{prefix}-worker-{id}`,\n            // and task worker processes will be named `{prefix}-task-worker-{id}`\n            'process-name' => 'your-app',\n        ],\n    ],\n];\n\n\n\n\n\nSSL support\n\n\nBy default, Swoole is not compiled with SSL support. To enable SSL in Swoole, it\nmust be configured with the \n--enable-openssl\n or\n\n--with-openssl-dir=/path/to/openssl\n option.\n\n\n\n\nServing static files\n\n\nWe support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant \nZend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\nOur static resource capabilities are fairly comprehensive; please see the\n\nchapter on static resources\n for full details on\nconfiguration.",
            "title": "Introduction"
        },
        {
            "location": "/v2/intro/#swoole",
            "text": "Swoole  is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.",
            "title": "Swoole"
        },
        {
            "location": "/v2/intro/#install-swoole",
            "text": "You can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:  $ pecl install swoole  For more information on the extension,  visit its package details on PECL .",
            "title": "Install swoole"
        },
        {
            "location": "/v2/intro/#install-zend-expressive-swoole",
            "text": "To install this package, use  Composer :  $ composer require zendframework/zend-expressive-swoole",
            "title": "Install zend-expressive-swoole"
        },
        {
            "location": "/v2/intro/#swoole-with-expressive",
            "text": "zend-expressive-swoole enables an Expressive application to be executed with\nthe  Swoole  extension. This means you can run the\napplication from the command line,  without requiring a web server .  You can run the application using the following command:  $ ./vendor/bin/zend-expressive-swoole start  This command will execute Swoole on  localhost  via port  8080 .",
            "title": "Swoole with Expressive"
        },
        {
            "location": "/v2/intro/#other-commands",
            "text": "To get a list of all available commands, run the command without arguments:  $ ./vendor/bin/zend-expressive-swoole  If you add the argument  help  before any command name, the tooling will\nprovide you with more detailed information on that command.",
            "title": "Other commands"
        },
        {
            "location": "/v2/intro/#expressive-skeleton-versions-prior-to-310",
            "text": "The above will work immediately after installing zend-expressive-swoole if you\nare using a version of  zend-expressive-skeleton \nfrom 3.1.0 or later.  For applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as  config/autoload/zend-expressive-swoole.global.php \nor  config/autoload/zend-expressive-swoole.local.php  with the following\ncontents:  <?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();   You can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:  // In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];",
            "title": "Expressive skeleton versions prior to 3.1.0"
        },
        {
            "location": "/v2/intro/#providing-additional-swoole-configuration",
            "text": "You can also configure the Swoole HTTP server using an  options  key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:  // config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        // Available in Swoole 4.1 and up; enables coroutine support\n        // for most I/O operations:\n        'enable_coroutine' => true,\n\n        // Configure Swoole HTTP Server:\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS;\n                                   // SWOOLE_BASE is the default\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server\n            'options' => [\n                // Set the SSL certificate and key paths for SSL support:\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n                // Whether or not the HTTP server should use coroutines;\n                // enabled by default, and generally should not be disabled:\n                'enable_coroutine' => true,\n\n                // Overwrite the default location of the pid file;\n                // required when you want to run multiple instances of your service in different ports:\n                'pid_file' => 'path/to/pid_file.pid',\n            ],\n\n            // Since 2.1.0: Set the process name prefix.\n            // The master process will be named `{prefix}-master`,\n            // worker processes will be named `{prefix}-worker-{id}`,\n            // and task worker processes will be named `{prefix}-task-worker-{id}`\n            'process-name' => 'your-app',\n        ],\n    ],\n];",
            "title": "Providing additional Swoole configuration"
        },
        {
            "location": "/v2/intro/#ssl-support",
            "text": "By default, Swoole is not compiled with SSL support. To enable SSL in Swoole, it\nmust be configured with the  --enable-openssl  or --with-openssl-dir=/path/to/openssl  option.",
            "title": "SSL support"
        },
        {
            "location": "/v2/intro/#serving-static-files",
            "text": "We support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant  Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .\nOur static resource capabilities are fairly comprehensive; please see the chapter on static resources  for full details on\nconfiguration.",
            "title": "Serving static files"
        },
        {
            "location": "/v2/static-resources/",
            "text": "Static Resources\n\n\nOne feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.\n\n\nTo enable this, the package provides an alternate\n\nRequestHandlerRunner\n\nimplementation via the class \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n\nthat performs two duties:\n\n\n\n\nIf a static resource is matched, it serves that.\n\n\nOtherwise, it passes off handling to the composed application pipeline.\n\n\n\n\nInternally, the \nSwooleRequestHandlerRunner\n composes another class, a \n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n instance. This instance\nis passed the Swoole request and response, and returns a value indicating\nwhether or not it was able to identify and serve a matching static resource.\n\n\nOur default implementation, \nZend\\Expressive\\Swoole\\StaticResourceHandler\n,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.\n\n\n\n\nDisabling static resources\n\n\n\n\nSince 2.1.0\n\n\n\n\nIf you want to disable serving of static resources, you can do so in two ways.\n\n\nIf you have a custom factory for the \nSwooleRequestHandlerRunner\n, or are\ninstantiating it manually, pass a null value for the sixth argument of its\nconstructor. As an example, within a factory:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Swoole\\Http\\Server as SwooleHttpServer;\nuse Zend\\Expressive\\ApplicationPipeline;\nuse Zend\\Expressive\\Swoole;\n\nfunction (ContainerInterface $container) : Swoole\\SwooleRequestHandlerRunner\n{\n    return new SwooleRequestHandlerRunner(\n        $container->get(ApplicationPipeline::class),\n        $container->get(ServerRequestInterface::class),\n        $container->get(Swoole\\ServerRequestErrorResponseGenerator::class),\n        $container->get(Swoole\\PidManager::class),\n        $container->get(SwooleHttpServer::class),\n        null, // No static resource handler!\n        $container->has(Swoole\\Log\\AccessLogInterface::class\n            ? $container->get(Swool\\Log\\AccessLogInterface::class\n            : null\n    );\n}\n\n\n\nIf you are using the default factory provided (\nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunnerFactory\n),\nyou can also disable the functionality via configuration. To do this, set the\n\nzend-expressive-swoole.swoole-http-server.static-files.enable\n flag to\nboolean \nfalse\n:\n\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'enable' => false,\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nMiddleware\n\n\nThe \nStaticResourceHandler\n implementation performs its work by composing a\nqueue of middleware to execute when attempting to serve a matched file. Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:\n\n\n\n\n\n\nCacheControlMiddleware\n will set a \nCache-Control\n header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the \nCache-Control\n directive to\n  use when the match occurs.\n\n\n\n\n\n\nClearStatCacheMiddleware\n will, if configured to do so, call\n  \nclearstatcache()\n either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.\n\n\n\n\n\n\nContentTypeFilterMiddleware\n checks the incoming filename against a map of\n  known extensions and their associated Content-Type values. If it cannot\n  match the file, it returns a value indicating no match was found so that the\n  application can continue processing the request. Otherwise, it provides the\n  Content-Type for the associated response. This middleware is generally best\n  used as the outermost layer, to ensure no other middleware executes in the\n  case that the file cannot be matched.\n\n\n\n\n\n\nETagMiddleware\n will set an \nETag\n header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the \nETag\n\n  header value matches either an \nIf-Match\n or \nIf-None-Match\n request header,\n  it will provide a response status of \n304\n and disable sending content.\n\n\n\n\n\n\nGzipMiddleware\n detects the \nAccept-Encoding\n request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.\n\n\n\n\n\n\nHeadMiddleware\n will force an empty response. (The status and headers may be\n  set by other middleware.)\n\n\n\n\n\n\nLastModifiedMiddleware\n will set a \nLast-Modified\n header using the\n  \nfilemtime()\n value of the requested resource. If the header value is later\n  than an \nIf-Modified-Since\n  request header, it will provide a response status\n  of \n304\n and disable sending content.\n\n\n\n\n\n\nMethodNotAllowedMiddleware\n will set the response status to \n405\n, and set an\n  \nAllow\n header indicating the allowed methods when an unsupported request\n  method is provided.\n\n\n\n\n\n\nOptionsMiddleware\n will force an empty response with an \nAllow\n header set\n  to the allowed methods. (Other headers may also be present!)\n\n\n\n\n\n\nBy default, these are registered in the following order, contingent on\nconfiguration being provided:\n\n\n\n\nContentTypeFilterMiddleware\n\n\nMethodNotAllowedMiddleware\n\n\nOptionsMiddleware\n\n\nHeadMiddleware\n\n\nGzipMiddleware\n\n\nClearStatCacheMiddleware\n\n\nCacheControlMiddleware\n\n\nLastModifiedMiddleware\n\n\nETagMiddleware\n\n\n\n\nThis approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the \nLast-Modified\n or \nETag\n headers); it also\nensures that all possible headers are provided whenever possible (e.g., a \nHEAD\n\nrequest should also expose \nCache-Control\n, \nLast-Modified\n, and \nETag\n\nheaders).\n\n\n\n\nProviding your own middleware\n\n\nIf you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate\n\nStaticResourceHandler\n factory. In most cases, you can extend\n\nStaticResourceHandlerFactory\n and override the \nconfigureMiddleware(array\n$config) : array\n method to do so. Be sure to remember to add a \ndependencies\n\nsetting mapping the \nStaticResourceHandlerInterface\n service to your new factory\nwhen done!\n\n\n\n\nConfiguration\n\n\nWe provide a factory for the \nStaticResourceHandler\n that uses a\nconfiguration-driven approach in order to:\n\n\n\n\nSet the document root.\n\n\nSet the map of allowed extensions to content-types.\n\n\nConfigure and provide middleware.\n\n\n\n\nThe following demonstrates all currently available configuration options:\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Since 2.1.0: Set to false to disable any serving of static\n                // files; all other configuration will then be ignored.\n                'enable' => true,\n\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nSecurity warning\n\n\nNever add \nphp\n as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!\n\n\nDocument root\n\n\nIf no \ndocument_root\n configuration is present, the default is to use\n\ngetcwd() . '/public'\n. If either the configured or default document root\ndoes not exist, we raise an exception.\n\n\nDefault extension/content-types\n\n\nBy default, we serve files with extensions in the whitelist defined in the\nconstant \nZend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\n\n\n\n\nConfiguration Example\n\n\nThe example which follows provides the following options:\n\n\n\n\nSets the document root to \n/var/www/htdocs\n.\n\n\nAdds a custom extension / content-type map.\n\n\nProvides a clearstatcache interval of 2 hours.\n\n\nSelects the \"strong\" ETag algorithm.\n\n\nIndicates a gzip compression level of 3.\n\n\nSets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.\n\n\nSets Cache-Control directives for plain text files.\n\n\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'enable'        => true,\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nWriting Middleware\n\n\nStatic resource middleware must implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface\n, which\ndefines the following:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}\n\n\n\nThe \n$next\n argument has the following signature:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;\n\n\n\nTypically, middleware will look something like this:\n\n\n$response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.\n\n\n\nMiddleware either produces or manipulates a\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse\n instance.\nThat class looks like the following:\n\n\nclass StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * Call this method to indicate that the request cannot be served as a\n     * static resource. The request runner will then proceed to execute\n     * the associated application in order to generate the response.\n     */\n    public function markAsFailure() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    /**\n     * Use this within a response content callback to set the associated\n     * Content-Length of the generated response. Loggers can then query\n     * for this information in order to provide that information in the logs.\n     */\n    public function setContentLength(int $length) : void;\n\n    public function setStatus(int $status) : void;\n}\n\n\n\nMost middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via \ndisableContent()\n).\nMiddleware that restricts access or filters out specific files will also use\n\nmarkAsFailure()\n.\n\n\n\n\nProviding an alternative mechanism for sending response content\n\n\nIn some cases, you may want to alter how the \nSwoole\\Http\\Response\n receives the\nbody content. By default, we use \nSwoole\\Http\\Response::sendfile()\n. However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the \nGzipMiddleware\n adds a compression filter to\na filehandle representing the file to send, and then calls\n\nSwoole\\Http\\Response::write()\n in a loop until all content is sent.\n\n\nTo perform work like this, you can call the\n\nStaticResourceResponse::setResponseContentCallback()\n method as detailed in the\nsection above within your middleware.\n\n\n\n\nAlternative static resource handlers\n\n\nAs noted at the beginning of this chapter, the \nSwooleRequestHandlerRunner\n\ncomposes a \nStaticResourceHandlerInterface\n instance in order to determine if a\nresource was matched by the request, and then to serve it.\n\n\nIf you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n:\n\n\ndeclare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Attempt to process a static resource based on the current request.\n     *\n     * If the resource cannot be processed, the method should return null.\n     * Otherwise, it should return the StaticResourceResponse that was used\n     * to send the Swoole response instance. The runner can then query this\n     * for content length and status.\n     */\n    public function processStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : ?StaticResourceHandler\\StaticResourceResponse;\n}\n\n\n\nOnce implemented, map the service\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n to a factory that\nreturns your custom implementation within your \ndependencies\n configuration.",
            "title": "Static Resources"
        },
        {
            "location": "/v2/static-resources/#static-resources",
            "text": "One feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.  To enable this, the package provides an alternate RequestHandlerRunner \nimplementation via the class  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner \nthat performs two duties:   If a static resource is matched, it serves that.  Otherwise, it passes off handling to the composed application pipeline.   Internally, the  SwooleRequestHandlerRunner  composes another class, a  Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  instance. This instance\nis passed the Swoole request and response, and returns a value indicating\nwhether or not it was able to identify and serve a matching static resource.  Our default implementation,  Zend\\Expressive\\Swoole\\StaticResourceHandler ,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.",
            "title": "Static Resources"
        },
        {
            "location": "/v2/static-resources/#disabling-static-resources",
            "text": "Since 2.1.0   If you want to disable serving of static resources, you can do so in two ways.  If you have a custom factory for the  SwooleRequestHandlerRunner , or are\ninstantiating it manually, pass a null value for the sixth argument of its\nconstructor. As an example, within a factory:  use Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Swoole\\Http\\Server as SwooleHttpServer;\nuse Zend\\Expressive\\ApplicationPipeline;\nuse Zend\\Expressive\\Swoole;\n\nfunction (ContainerInterface $container) : Swoole\\SwooleRequestHandlerRunner\n{\n    return new SwooleRequestHandlerRunner(\n        $container->get(ApplicationPipeline::class),\n        $container->get(ServerRequestInterface::class),\n        $container->get(Swoole\\ServerRequestErrorResponseGenerator::class),\n        $container->get(Swoole\\PidManager::class),\n        $container->get(SwooleHttpServer::class),\n        null, // No static resource handler!\n        $container->has(Swoole\\Log\\AccessLogInterface::class\n            ? $container->get(Swool\\Log\\AccessLogInterface::class\n            : null\n    );\n}  If you are using the default factory provided ( Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunnerFactory ),\nyou can also disable the functionality via configuration. To do this, set the zend-expressive-swoole.swoole-http-server.static-files.enable  flag to\nboolean  false :  return [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'enable' => false,\n            ],\n        ],\n    ],\n];",
            "title": "Disabling static resources"
        },
        {
            "location": "/v2/static-resources/#middleware",
            "text": "The  StaticResourceHandler  implementation performs its work by composing a\nqueue of middleware to execute when attempting to serve a matched file. Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:    CacheControlMiddleware  will set a  Cache-Control  header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the  Cache-Control  directive to\n  use when the match occurs.    ClearStatCacheMiddleware  will, if configured to do so, call\n   clearstatcache()  either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.    ContentTypeFilterMiddleware  checks the incoming filename against a map of\n  known extensions and their associated Content-Type values. If it cannot\n  match the file, it returns a value indicating no match was found so that the\n  application can continue processing the request. Otherwise, it provides the\n  Content-Type for the associated response. This middleware is generally best\n  used as the outermost layer, to ensure no other middleware executes in the\n  case that the file cannot be matched.    ETagMiddleware  will set an  ETag  header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the  ETag \n  header value matches either an  If-Match  or  If-None-Match  request header,\n  it will provide a response status of  304  and disable sending content.    GzipMiddleware  detects the  Accept-Encoding  request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.    HeadMiddleware  will force an empty response. (The status and headers may be\n  set by other middleware.)    LastModifiedMiddleware  will set a  Last-Modified  header using the\n   filemtime()  value of the requested resource. If the header value is later\n  than an  If-Modified-Since   request header, it will provide a response status\n  of  304  and disable sending content.    MethodNotAllowedMiddleware  will set the response status to  405 , and set an\n   Allow  header indicating the allowed methods when an unsupported request\n  method is provided.    OptionsMiddleware  will force an empty response with an  Allow  header set\n  to the allowed methods. (Other headers may also be present!)    By default, these are registered in the following order, contingent on\nconfiguration being provided:   ContentTypeFilterMiddleware  MethodNotAllowedMiddleware  OptionsMiddleware  HeadMiddleware  GzipMiddleware  ClearStatCacheMiddleware  CacheControlMiddleware  LastModifiedMiddleware  ETagMiddleware   This approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the  Last-Modified  or  ETag  headers); it also\nensures that all possible headers are provided whenever possible (e.g., a  HEAD \nrequest should also expose  Cache-Control ,  Last-Modified , and  ETag \nheaders).",
            "title": "Middleware"
        },
        {
            "location": "/v2/static-resources/#providing-your-own-middleware",
            "text": "If you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate StaticResourceHandler  factory. In most cases, you can extend StaticResourceHandlerFactory  and override the  configureMiddleware(array\n$config) : array  method to do so. Be sure to remember to add a  dependencies \nsetting mapping the  StaticResourceHandlerInterface  service to your new factory\nwhen done!",
            "title": "Providing your own middleware"
        },
        {
            "location": "/v2/static-resources/#configuration",
            "text": "We provide a factory for the  StaticResourceHandler  that uses a\nconfiguration-driven approach in order to:   Set the document root.  Set the map of allowed extensions to content-types.  Configure and provide middleware.   The following demonstrates all currently available configuration options:  // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Since 2.1.0: Set to false to disable any serving of static\n                // files; all other configuration will then be ignored.\n                'enable' => true,\n\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/v2/static-resources/#security-warning",
            "text": "Never add  php  as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!",
            "title": "Security warning"
        },
        {
            "location": "/v2/static-resources/#document-root",
            "text": "If no  document_root  configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root\ndoes not exist, we raise an exception.",
            "title": "Document root"
        },
        {
            "location": "/v2/static-resources/#default-extensioncontent-types",
            "text": "By default, we serve files with extensions in the whitelist defined in the\nconstant  Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .",
            "title": "Default extension/content-types"
        },
        {
            "location": "/v2/static-resources/#configuration-example",
            "text": "The example which follows provides the following options:   Sets the document root to  /var/www/htdocs .  Adds a custom extension / content-type map.  Provides a clearstatcache interval of 2 hours.  Selects the \"strong\" ETag algorithm.  Indicates a gzip compression level of 3.  Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.  Sets Cache-Control directives for plain text files.   // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'enable'        => true,\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration Example"
        },
        {
            "location": "/v2/static-resources/#writing-middleware",
            "text": "Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which\ndefines the following:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}  The  $next  argument has the following signature:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;  Typically, middleware will look something like this:  $response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.  Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse  instance.\nThat class looks like the following:  class StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * Call this method to indicate that the request cannot be served as a\n     * static resource. The request runner will then proceed to execute\n     * the associated application in order to generate the response.\n     */\n    public function markAsFailure() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    /**\n     * Use this within a response content callback to set the associated\n     * Content-Length of the generated response. Loggers can then query\n     * for this information in order to provide that information in the logs.\n     */\n    public function setContentLength(int $length) : void;\n\n    public function setStatus(int $status) : void;\n}  Most middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via  disableContent() ).\nMiddleware that restricts access or filters out specific files will also use markAsFailure() .",
            "title": "Writing Middleware"
        },
        {
            "location": "/v2/static-resources/#providing-an-alternative-mechanism-for-sending-response-content",
            "text": "In some cases, you may want to alter how the  Swoole\\Http\\Response  receives the\nbody content. By default, we use  Swoole\\Http\\Response::sendfile() . However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the  GzipMiddleware  adds a compression filter to\na filehandle representing the file to send, and then calls Swoole\\Http\\Response::write()  in a loop until all content is sent.  To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback()  method as detailed in the\nsection above within your middleware.",
            "title": "Providing an alternative mechanism for sending response content"
        },
        {
            "location": "/v2/static-resources/#alternative-static-resource-handlers",
            "text": "As noted at the beginning of this chapter, the  SwooleRequestHandlerRunner \ncomposes a  StaticResourceHandlerInterface  instance in order to determine if a\nresource was matched by the request, and then to serve it.  If you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface :  declare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Attempt to process a static resource based on the current request.\n     *\n     * If the resource cannot be processed, the method should return null.\n     * Otherwise, it should return the StaticResourceResponse that was used\n     * to send the Swoole response instance. The runner can then query this\n     * for content length and status.\n     */\n    public function processStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : ?StaticResourceHandler\\StaticResourceResponse;\n}  Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  to a factory that\nreturns your custom implementation within your  dependencies  configuration.",
            "title": "Alternative static resource handlers"
        },
        {
            "location": "/v2/logging/",
            "text": "Logging\n\n\nWeb servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.\n\n\nOut-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.\n\n\nWe log a number of items:\n\n\n\n\nWhen the web server starts, indicating the host and port on which it is running.\n\n\nWhen workers start, including the working directory and worker ID.\n\n\nWhen the web server stops.\n\n\nWhen the web server reloads workers.\n\n\nEach request (more on this below)\n\n\n\n\nBy default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any \nPSR-3 compliant logger\n to\nlog application details. We emit logs detailing server operations using the\npriority \nPsr\\Log\\LogLevel::NOTICE\n (unless detailing an error, such as\ninability to reload)), while \nPsr\\Log\\LogLevel::INFO\n and \nPsr\\Log\\LogLevel::ERROR\n\nare used to log requests (errors are used for response statuses greater than or\nequal to 400).\n\n\nAccess Logs\n\n\nTechnically, the \nSwooleRequestHandlerRunner\n doesn't use PSR-3 loggers\ndirectly, but, rather, instances of \nZend\\Expressive\\Swoole\\Log\\AccessLogInterface\n.\nThis package-specific interface extends the PSR-3 interface to add two methods:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Request;\nuse Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse;\n\ninterface AccessLogInterface extends LoggerInterface\n{\n    public function logAccessForStaticResource(\n        Request $request,\n        StaticResourceResponse $response\n    ) : void;\n\n    public function logAccessForPsr7Resource(\n        Request $request,\n        ResponseInterface $response\n    ) : void;\n}\n\n\n\nTo allow usage of a standard PSR-3 logger, we also provide a decorator,\n\nZend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator\n, which decorates the PSR-3\nlogger and provides a standard implementation for the two methods listed above.\nIf you have defined a PSR-3 \nLoggerInterface\n service in your application, it\nwill be used automatically.\n\n\nFormatting logs\n\n\nThe Apache web server has long provided flexible and robust logging\ncapabilities, and its formats are used across a variety of web servers and\nlogging platforms. As such, we have chosen to use its formats for our standard\nimplementation. However, we allow you to plug in your own system as needed.\n\n\nYou can refer to the \nApache mod_log_config documentation\n\nin order to understand the available placeholders available for format strings.\n\n\nFormatting is provided to the \nPsr3AccessLogDecorator\n via instances of the\ninterface \nZend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface\n:\n\n\ninterface AccessLogFormatterInterface\n{\n    public function format(AccessLogDataMap $map) : string;\n}\n\n\n\nAccessLogDataMap\n is a class used internally by the \nPsr3AccessLogDecorator\n in\norder to map Apache log placeholders to request/response values.\n\n\nOur default \nAccessLogFormatterInterface\n implementation, \nAccessLogFormatter\n,\nprovides constants referencing the most common formats, but also allows you to\nuse arbitrary log formats that use the standard Apache placeholders. The formats\nwe include by default are:\n\n\n\n\nAccessLogFormatter::FORMAT_COMMON\n: Apache common log format: \n%h %l %u %t \"%r\" %>s %b\n\n\nAccessLogFormatter::FORMAT_COMMON_VHOST\n: Apache common log format + vhost: \n%v %h %l %u %t \"%r\" %>s %b\n\n\nAccessLogFormatter::FORMAT_COMBINED\n: Apache combined log format: \n%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"\n\n\nAccessLogFormatter::FORMAT_REFERER\n: \n%{Referer}i -> %U\n\n\nAccessLogFormatter::FORMAT_AGENT\n: \n%{User-Agent}i\n\n\nAccessLogFormatter::FORMAT_VHOST\n: Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b';\n\n\nAccessLogFormatter::FORMAT_COMMON_DEBIAN\n: Debian variant of common log format: \n%h %l %u %t \u201c%r\u201d %>s %O\n;\n\n\nAccessLogFormatter::FORMAT_COMBINED_DEBIAN\n: Debian variant of combined log format: \n%h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d\n;\n\n\nAccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN\n: Debian variant of combined log format + vhost: \n%v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\"\n;\n\n\n\n\nConfiguring a logger\n\n\nYou may subsitute your own logger implementation into the Swoole request handler\nrunner.\n\n\nManual usage\n\n\nIf you are manually instantiating a \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n\ninstance, you may provide it as the seventh argument to the constructor:\n\n\nuse Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner;\n\n$runner = new SwooleRequestHandlerRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $pidManager,\n    $serverFactory,\n    $staticResourceHandler,\n    $logger // <-- AccessLoggerInterface instance\n);\n\n\n\nContainer usage\n\n\nIf you are using a \nPSR-11\n container, the\n\nSwooleRequestHandlerRunnerFactory\n will retrieve a log instance using the\n\nZend\\Expressive\\Swoole\\Log\\AccessLogInterface\n service.\n\n\nYou have two options for substituting your own logger from there.\n\n\nFirst, if you already have a service which resolves to a \nPsr\\Log\\LoggerInterface\n instance,\nyou can configure it by providing its name:\n\n\n'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'logger-name' => 'my_logger', // define the logger service name here\n        ],\n    ],\n],\n\n\n\nIf you don't want to manually provide the service name but you are okay with re-using your\nexisting PSR-3 logger, the provided \nZend\\Expressive\\Swoole\\Log\\AccessLogFactory\n will use\nthe \nPsr\\Log\\LoggerInterface\n service to create a \nPsr3AccessLogDecorator\n instance.\n\n\nThis factory also allows you to specify a custom \nAccessLogFormatterInterface\n\ninstance if you want. It will look up a service by the fully-qualified interface\nname, and use it if present. Otherwise, it creates an \nAccessLogFormatter\n\ninstance for you.\n\n\nIn both cases the factory will also look at the following configuration values:\n\n\n'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'format' => string, // one of the AccessLogFormatter::FORMAT_*\n                                // constants, or a custom format string\n            'use-hostname-lookups' => bool, // Set to true to enable hostname lookups\n        ],\n    ],\n],\n\n\n\nUsing Monolog as a PSR-3 logger\n\n\nWhen using \nMonolog\n with a \nStreamHandler\n,\nyou must supply a file or a stream resource descriptor. We recommend using one\nof the following:\n\n\n\n\n\n\nphp://stdout\n is a good choice, as this will generally write to the current\n  console.\n\n\n\n\n\n\nphp://stderr\n is also a good choice, as this will generally write to the\n  current console, and allows you to filter based on that output stream.\n\n\n\n\n\n\nWhen using \nDocker\n, generally one of either\n  \n/proc/1/fd/1\n or \n/proc/1/fd/2\n can be used, and are analogous to \nSTDOUT\n\n  and \nSTDERR\n, respectively.  We recommend using \nphp://stdout\n and\n  \nphp://stderr\n instead, as these will be mapped to the correct locations by\n  the language.\n\n\n\n\n\n\n\n\nErrorLogHandler\n\n\nIf you plan to write to \nSTDERR\n, you might consider instead using the\nMonolog \nErrorLogHandler\n, as this will use PHP's \nerror_log()\n mechanism to\nwrite to the configured PHP error log. You can then either introspect that\nlocation, or configure the \nerror_log\n \nphp.ini\n setting to point to\neither \n/dev/stderr\n or, if on Docker, \n/proc/1/fd/2\n.\n\n\n\n\nAdditionally, we recommend using the \nPsrLogMessageProcessor\n with any Monolog\nhandler to ensure that any templated parameters are expanded by the logger.\n\n\nAs an example, the following is a factory that wires a \nStreamHandler\n to a\n\nMonolog\\Logger\n instance. \n\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\nuse Monolog\\Processor\\PsrLogMessageProcessor;\n\nclass LoggerFactory\n{\n    public function __invoke(ContainerInterface $container) : LoggerInterface\n    {\n        $logger = new Logger('swoole-http-server');\n        $logger->pushHandler(new StreamHandler(\n            'php://stdout',\n            Logger::INFO,\n            $bubble = true,\n            $expandNewLines = true\n        ));\n        $logger->pushProcessor(new PsrLogMessageProcessor());\n        return $logger;\n    }\n}\n\n\n\nIf you then wire this to the \nPsr\\Log\\LoggerInterface\n service, it will be used\nby Swoole for the purposes of access logs as well.",
            "title": "Logging"
        },
        {
            "location": "/v2/logging/#logging",
            "text": "Web servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.  Out-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.  We log a number of items:   When the web server starts, indicating the host and port on which it is running.  When workers start, including the working directory and worker ID.  When the web server stops.  When the web server reloads workers.  Each request (more on this below)   By default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any  PSR-3 compliant logger  to\nlog application details. We emit logs detailing server operations using the\npriority  Psr\\Log\\LogLevel::NOTICE  (unless detailing an error, such as\ninability to reload)), while  Psr\\Log\\LogLevel::INFO  and  Psr\\Log\\LogLevel::ERROR \nare used to log requests (errors are used for response statuses greater than or\nequal to 400).",
            "title": "Logging"
        },
        {
            "location": "/v2/logging/#access-logs",
            "text": "Technically, the  SwooleRequestHandlerRunner  doesn't use PSR-3 loggers\ndirectly, but, rather, instances of  Zend\\Expressive\\Swoole\\Log\\AccessLogInterface .\nThis package-specific interface extends the PSR-3 interface to add two methods:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Request;\nuse Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse;\n\ninterface AccessLogInterface extends LoggerInterface\n{\n    public function logAccessForStaticResource(\n        Request $request,\n        StaticResourceResponse $response\n    ) : void;\n\n    public function logAccessForPsr7Resource(\n        Request $request,\n        ResponseInterface $response\n    ) : void;\n}  To allow usage of a standard PSR-3 logger, we also provide a decorator, Zend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3\nlogger and provides a standard implementation for the two methods listed above.\nIf you have defined a PSR-3  LoggerInterface  service in your application, it\nwill be used automatically.",
            "title": "Access Logs"
        },
        {
            "location": "/v2/logging/#formatting-logs",
            "text": "The Apache web server has long provided flexible and robust logging\ncapabilities, and its formats are used across a variety of web servers and\nlogging platforms. As such, we have chosen to use its formats for our standard\nimplementation. However, we allow you to plug in your own system as needed.  You can refer to the  Apache mod_log_config documentation \nin order to understand the available placeholders available for format strings.  Formatting is provided to the  Psr3AccessLogDecorator  via instances of the\ninterface  Zend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface :  interface AccessLogFormatterInterface\n{\n    public function format(AccessLogDataMap $map) : string;\n}  AccessLogDataMap  is a class used internally by the  Psr3AccessLogDecorator  in\norder to map Apache log placeholders to request/response values.  Our default  AccessLogFormatterInterface  implementation,  AccessLogFormatter ,\nprovides constants referencing the most common formats, but also allows you to\nuse arbitrary log formats that use the standard Apache placeholders. The formats\nwe include by default are:   AccessLogFormatter::FORMAT_COMMON : Apache common log format:  %h %l %u %t \"%r\" %>s %b  AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost:  %v %h %l %u %t \"%r\" %>s %b  AccessLogFormatter::FORMAT_COMBINED : Apache combined log format:  %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"  AccessLogFormatter::FORMAT_REFERER :  %{Referer}i -> %U  AccessLogFormatter::FORMAT_AGENT :  %{User-Agent}i  AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b';  AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format:  %h %l %u %t \u201c%r\u201d %>s %O ;  AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format:  %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d ;  AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost:  %v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\" ;",
            "title": "Formatting logs"
        },
        {
            "location": "/v2/logging/#configuring-a-logger",
            "text": "You may subsitute your own logger implementation into the Swoole request handler\nrunner.",
            "title": "Configuring a logger"
        },
        {
            "location": "/v2/logging/#manual-usage",
            "text": "If you are manually instantiating a  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner \ninstance, you may provide it as the seventh argument to the constructor:  use Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner;\n\n$runner = new SwooleRequestHandlerRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $pidManager,\n    $serverFactory,\n    $staticResourceHandler,\n    $logger // <-- AccessLoggerInterface instance\n);",
            "title": "Manual usage"
        },
        {
            "location": "/v2/logging/#container-usage",
            "text": "If you are using a  PSR-11  container, the SwooleRequestHandlerRunnerFactory  will retrieve a log instance using the Zend\\Expressive\\Swoole\\Log\\AccessLogInterface  service.  You have two options for substituting your own logger from there.  First, if you already have a service which resolves to a  Psr\\Log\\LoggerInterface  instance,\nyou can configure it by providing its name:  'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'logger-name' => 'my_logger', // define the logger service name here\n        ],\n    ],\n],  If you don't want to manually provide the service name but you are okay with re-using your\nexisting PSR-3 logger, the provided  Zend\\Expressive\\Swoole\\Log\\AccessLogFactory  will use\nthe  Psr\\Log\\LoggerInterface  service to create a  Psr3AccessLogDecorator  instance.  This factory also allows you to specify a custom  AccessLogFormatterInterface \ninstance if you want. It will look up a service by the fully-qualified interface\nname, and use it if present. Otherwise, it creates an  AccessLogFormatter \ninstance for you.  In both cases the factory will also look at the following configuration values:  'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'format' => string, // one of the AccessLogFormatter::FORMAT_*\n                                // constants, or a custom format string\n            'use-hostname-lookups' => bool, // Set to true to enable hostname lookups\n        ],\n    ],\n],",
            "title": "Container usage"
        },
        {
            "location": "/v2/logging/#using-monolog-as-a-psr-3-logger",
            "text": "When using  Monolog  with a  StreamHandler ,\nyou must supply a file or a stream resource descriptor. We recommend using one\nof the following:    php://stdout  is a good choice, as this will generally write to the current\n  console.    php://stderr  is also a good choice, as this will generally write to the\n  current console, and allows you to filter based on that output stream.    When using  Docker , generally one of either\n   /proc/1/fd/1  or  /proc/1/fd/2  can be used, and are analogous to  STDOUT \n  and  STDERR , respectively.  We recommend using  php://stdout  and\n   php://stderr  instead, as these will be mapped to the correct locations by\n  the language.",
            "title": "Using Monolog as a PSR-3 logger"
        },
        {
            "location": "/v2/logging/#errorloghandler",
            "text": "If you plan to write to  STDERR , you might consider instead using the\nMonolog  ErrorLogHandler , as this will use PHP's  error_log()  mechanism to\nwrite to the configured PHP error log. You can then either introspect that\nlocation, or configure the  error_log   php.ini  setting to point to\neither  /dev/stderr  or, if on Docker,  /proc/1/fd/2 .   Additionally, we recommend using the  PsrLogMessageProcessor  with any Monolog\nhandler to ensure that any templated parameters are expanded by the logger.  As an example, the following is a factory that wires a  StreamHandler  to a Monolog\\Logger  instance.   use Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\nuse Monolog\\Processor\\PsrLogMessageProcessor;\n\nclass LoggerFactory\n{\n    public function __invoke(ContainerInterface $container) : LoggerInterface\n    {\n        $logger = new Logger('swoole-http-server');\n        $logger->pushHandler(new StreamHandler(\n            'php://stdout',\n            Logger::INFO,\n            $bubble = true,\n            $expandNewLines = true\n        ));\n        $logger->pushProcessor(new PsrLogMessageProcessor());\n        return $logger;\n    }\n}  If you then wire this to the  Psr\\Log\\LoggerInterface  service, it will be used\nby Swoole for the purposes of access logs as well.",
            "title": "ErrorLogHandler"
        },
        {
            "location": "/v2/async-tasks/",
            "text": "Triggering Async Tasks\n\n\nApplication resources requiring lengthy processing are not uncommon. In order to\nprevent these processes from impacting user experience, particularly when the\nuser does not need to wait for the process to complete, we often delegate these\nto a \nmessage queue\n.\n\n\nWhile message queues are powerful, they also require additional infrastructure\nfor your application, and can be hard to justify when you have a small number of\nheavy processes, or a small number of users.\n\n\nIn order to facilitate async processing, Swoole servers provides task worker\nprocesses, allowing your application to trigger tasks without the need for an\nexternal message queue, and without impacting the server worker processes\n\u2014 allowing your application to continue responding to requests while the\nserver processes your task.\n\n\nConfiguring the Server Process\n\n\nIn order to take advantage of this feature, you will first need to configure the\nserver to start up task workers. In your local configuration for the server,\nyou'll need to add \ntask_worker_num\n. The number of workers you configure define\nthe number of concurrent tasks that can be executed at once. Tasks are queued in\nthe order that they triggered, meaning that a \ntask_worker_num\n of 1 will offer\nno concurrency and tasks will execute one after the other.\n\n\n'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'host' => '127.0.0.1',\n        'port' => 8080,\n        'options' => [\n            'worker_num'      => 4, // The number of HTTP Server Workers\n            'task_worker_num' => 4, // The number of Task Workers\n        ],\n    ],\n];\n\n\n\n\n\nNo CLI option for task_worker_num\n\n\nUnlike \nworker_num\n, there is no CLI option for \ntask_worker_num\n. This is\nbecause enabling the task worker also requires registering a task worker\nwith the server. To prevent accidental startup failures due to passing an\noption to specify the number of task workers without having registered a\ntask worker, we omitted the CLI option.\n\n\n\n\nTask Event Handlers\n\n\nWhen task workers are enabled, the Swoole server will now \nrequire\n that you\nregister two event callbacks with the server; without them, the server will\nrefuse to start.\n\n\nThe two events are:\n\n\n\n\ntask\n, which will define the code for handling tasks.\n\n\nfinish\n, which will execute when a task has completed.\n\n\n\n\nRegistering the Handlers\n\n\nThe signature for the \ntask\n event handler is:\n\n\nfunction (\n    \\Swoole\\Http\\Server $server,\n    int $taskId,\n    int $sourceWorkerId,\n    $dataForWorker\n) : void\n\nwhere:\n\n\n\n\n$server\n is the main HTTP server process\n\n\n$taskId\n is a number that increments each time the server triggers a new task.\n\n\n$sourceWorkerId\n is an integer that defines the worker process that is\n  executing the workload.\n\n\n$dataForWorker\n contains the value passed to the \n$server->task()\n method\n  when initially triggering the task. This value can be any PHP value, with the\n  exception of a \nresource\n.\n\n\n\n\nTo register the handler with the server, you must call it's \non()\n method,\n\nbefore\n the server has been started:\n\n\n$server->on('task', $callable);\n\n\n\nAs previously mentioned, you must also register an event handler for the\n\nfinish\n event. This callback for this event should have the following\nsignature:\n\n\nfunction (\n    \\Swoole\\Http\\Server $server,\n    int $taskId,\n    $userData\n) : void\n\n\n\nThe first two parameters are identical to the \ntask\n event handler. The\n\n$userData\n parameter will contain the return value of the \ntask\n event\nhandler. \n\n\nRegistering your callable for the \nfinish\n event is accomplished like this:\n\n\n$server->on('finish', $callable);\n\n\n\n\n\nThere can be only one\n\n\nThere can be \nonly one\n event handler per event type. Subsequent calls to\n\non('<EventName>')\n replace the previously registered callable.\n\n\nFinishing a task\n\n\nIf you do not return anything from your \ntask\n event handler, the\n\nfinish\n handler \nwill not be called\n. The Swoole documentation recommends\nthat the task worker callback manually finish the task in these situations:\n\n\n$server->finish('');\n\n\n\nEven if you do not call the above method, the handler \nmust\n be defined, or\nthe server will refuse to start.\n\n\n\n\nAn example task worker\n\n\nThe following example code illustrates a task worker with logging capabilities\nthat uses a message notifier to process data:\n\n\n// In src/App/TaskWorker.php:\n\nnamespace App;\n\nuse Psr\\EventDispatcher\\MessageInterface;\nuse Psr\\EventDispatcher\\MessageNotifierInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Throwable;\n\nclass TaskWorker\n{\n    private $notifier;\n    private $logger;\n\n    public function __construct(LoggerInterface $logger, MessageNotifierInterface $notifier)\n    {\n        $this->logger = $logger;\n        $this->notifier = $notifier;\n    }\n\n    public function __invoke($server, $taskId, $fromId, $data)\n    {\n        if (! $data instanceof MessageInterface) {\n            $this->logger->error('Invalid data type provided to task worker: {type}', [\n                'type' => is_object($data) ? get_class($data) : gettype($data)\n            ]);\n            return;\n        }\n\n        $this->logger->notice('Starting work on task {taskId} using data: {data}', [\n            'taskId' => $taskId,\n            'data' => json_encode($data),\n        ]);\n\n        try {\n            $this->notifier->notify($data);\n        } catch (Throwable $e) {\n            $this->logger->error('Error processing task {taskId}: {error}', [\n                'taskId' => $taskId,\n                'error' => $e->getTraceAsString(),\n            ]);\n        }\n\n        // Notify the server that processing of the task has finished:\n        $server->finish('');\n    }\n}\n\n\n\nThis invokable class needs to be attached to the \n$server->on('task')\n event\nbefore the server has started. The easiest place to accomplish this is in a\n\ndelegator factory\n\ntargeting the Swoole HTTP server. First, we'll create the delegator factory:\n\n\n// In src/App/TaskWorkerDelegator.php:\n\nnamespace App;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Server as HttpServer;\n\nclass TaskWorkerDelegator\n{\n    public function __invoke(ContainerInterface $container, $serviceName, callable $callback) : HttpServer\n    {\n        $server = $callback();\n        $logger = $container->get(LoggerInterface::class);\n\n        $server->on('task', $container->get(TaskWorker::class));\n        $server->on('finish', function ($server, $taskId, $data) use ($logger) {\n            $logger->notice('Task #{taskId} has finished processing', ['taskId' => $taskId]);\n        });\n\n        return $server;\n    }\n}\n\n\n\nNext, we'll register it with our container:\n\n\n// In config/autoload/dependencies.php:\n\nreturn [\n    'dependencies' => [\n        'delegators' => [\n            \\Swoole\\Http\\Server::class => [\n                \\App\\TaskWorkerDelegator::class,\n            ],\n        ],\n    ],\n];\n\n\n\nWith this in place, we can now trigger tasks within our application. In the\nscenario outlined above, the task worker expects \nmessages\n; it then \nnotifies\n\nlisteners of that message so they may respond to it.\n\n\nTriggering Tasks in Middleware\n\n\nConsidering that this library provides an application runner for middleware\napplications, you will likely trigger tasks from within your middleware or\nrequest handlers. In each case, you will need to compose the Swoole HTTP server\ninstance as a class dependency, as tasks are triggered via the server via its\n\ntask()\n method. The method can accept any value except a resource as an\nargument.\n\n\nIn the example below, \nContactMessage\n will implement the \nMessageInterface\n\nfrom the above example. The request handler uses values from the request to\ncreate the \nContactMessage\n instance, and then create a task from it. It then\nimmediately returns a response.\n\n\n// in src/App/Handler/TaskTriggeringHandler.php:\n\nnamespace App\\Handler;\n\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Swoole\\Http\\Server as HttpServer;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TaskTriggeringHandler implements RequestHandlerInterface\n{\n    private $responseFactory;\n    private $server;\n    private $template;\n\n    public function __construct(\n        HttpServer $server,\n        TemplateRendererInterface $template,\n        ResponseFactoryInterface $responseFactory\n    ) {\n        $this->server          = $server;\n        $this->template        = $template;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        // Gather data from request\n        $data = $request->getParsedBody();\n\n        // A fictonal event describing a contact request:\n        $event = new ContactEvent([\n            'to'      => $data['email'],\n            'subject' => $data['subject'],\n            'message' => $data['message'],\n        ]);\n\n        // task() returns a task identifier, if you want to use it; otherwise,\n        // you can ignore the return value.\n        $taskIdentifier = $this->server->task($event);\n\n        // The task() method is asynchronous, so execution continues immediately.\n        $response = ($this->responseFactory()->createResponse())\n            ->withHeader('Content-Type', 'text/html');\n        $response->getBody()->write($this->template->render('contact::thank-you', []);\n        return $response;\n    }\n}",
            "title": "Async Tasks"
        },
        {
            "location": "/v2/async-tasks/#triggering-async-tasks",
            "text": "Application resources requiring lengthy processing are not uncommon. In order to\nprevent these processes from impacting user experience, particularly when the\nuser does not need to wait for the process to complete, we often delegate these\nto a  message queue .  While message queues are powerful, they also require additional infrastructure\nfor your application, and can be hard to justify when you have a small number of\nheavy processes, or a small number of users.  In order to facilitate async processing, Swoole servers provides task worker\nprocesses, allowing your application to trigger tasks without the need for an\nexternal message queue, and without impacting the server worker processes\n\u2014 allowing your application to continue responding to requests while the\nserver processes your task.",
            "title": "Triggering Async Tasks"
        },
        {
            "location": "/v2/async-tasks/#configuring-the-server-process",
            "text": "In order to take advantage of this feature, you will first need to configure the\nserver to start up task workers. In your local configuration for the server,\nyou'll need to add  task_worker_num . The number of workers you configure define\nthe number of concurrent tasks that can be executed at once. Tasks are queued in\nthe order that they triggered, meaning that a  task_worker_num  of 1 will offer\nno concurrency and tasks will execute one after the other.  'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'host' => '127.0.0.1',\n        'port' => 8080,\n        'options' => [\n            'worker_num'      => 4, // The number of HTTP Server Workers\n            'task_worker_num' => 4, // The number of Task Workers\n        ],\n    ],\n];",
            "title": "Configuring the Server Process"
        },
        {
            "location": "/v2/async-tasks/#no-cli-option-for-task_worker_num",
            "text": "Unlike  worker_num , there is no CLI option for  task_worker_num . This is\nbecause enabling the task worker also requires registering a task worker\nwith the server. To prevent accidental startup failures due to passing an\noption to specify the number of task workers without having registered a\ntask worker, we omitted the CLI option.",
            "title": "No CLI option for task_worker_num"
        },
        {
            "location": "/v2/async-tasks/#task-event-handlers",
            "text": "When task workers are enabled, the Swoole server will now  require  that you\nregister two event callbacks with the server; without them, the server will\nrefuse to start.  The two events are:   task , which will define the code for handling tasks.  finish , which will execute when a task has completed.",
            "title": "Task Event Handlers"
        },
        {
            "location": "/v2/async-tasks/#registering-the-handlers",
            "text": "The signature for the  task  event handler is:  function (\n    \\Swoole\\Http\\Server $server,\n    int $taskId,\n    int $sourceWorkerId,\n    $dataForWorker\n) : void \nwhere:   $server  is the main HTTP server process  $taskId  is a number that increments each time the server triggers a new task.  $sourceWorkerId  is an integer that defines the worker process that is\n  executing the workload.  $dataForWorker  contains the value passed to the  $server->task()  method\n  when initially triggering the task. This value can be any PHP value, with the\n  exception of a  resource .   To register the handler with the server, you must call it's  on()  method, before  the server has been started:  $server->on('task', $callable);  As previously mentioned, you must also register an event handler for the finish  event. This callback for this event should have the following\nsignature:  function (\n    \\Swoole\\Http\\Server $server,\n    int $taskId,\n    $userData\n) : void  The first two parameters are identical to the  task  event handler. The $userData  parameter will contain the return value of the  task  event\nhandler.   Registering your callable for the  finish  event is accomplished like this:  $server->on('finish', $callable);",
            "title": "Registering the Handlers"
        },
        {
            "location": "/v2/async-tasks/#there-can-be-only-one",
            "text": "There can be  only one  event handler per event type. Subsequent calls to on('<EventName>')  replace the previously registered callable.",
            "title": "There can be only one"
        },
        {
            "location": "/v2/async-tasks/#finishing-a-task",
            "text": "If you do not return anything from your  task  event handler, the finish  handler  will not be called . The Swoole documentation recommends\nthat the task worker callback manually finish the task in these situations:  $server->finish('');  Even if you do not call the above method, the handler  must  be defined, or\nthe server will refuse to start.",
            "title": "Finishing a task"
        },
        {
            "location": "/v2/async-tasks/#an-example-task-worker",
            "text": "The following example code illustrates a task worker with logging capabilities\nthat uses a message notifier to process data:  // In src/App/TaskWorker.php:\n\nnamespace App;\n\nuse Psr\\EventDispatcher\\MessageInterface;\nuse Psr\\EventDispatcher\\MessageNotifierInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Throwable;\n\nclass TaskWorker\n{\n    private $notifier;\n    private $logger;\n\n    public function __construct(LoggerInterface $logger, MessageNotifierInterface $notifier)\n    {\n        $this->logger = $logger;\n        $this->notifier = $notifier;\n    }\n\n    public function __invoke($server, $taskId, $fromId, $data)\n    {\n        if (! $data instanceof MessageInterface) {\n            $this->logger->error('Invalid data type provided to task worker: {type}', [\n                'type' => is_object($data) ? get_class($data) : gettype($data)\n            ]);\n            return;\n        }\n\n        $this->logger->notice('Starting work on task {taskId} using data: {data}', [\n            'taskId' => $taskId,\n            'data' => json_encode($data),\n        ]);\n\n        try {\n            $this->notifier->notify($data);\n        } catch (Throwable $e) {\n            $this->logger->error('Error processing task {taskId}: {error}', [\n                'taskId' => $taskId,\n                'error' => $e->getTraceAsString(),\n            ]);\n        }\n\n        // Notify the server that processing of the task has finished:\n        $server->finish('');\n    }\n}  This invokable class needs to be attached to the  $server->on('task')  event\nbefore the server has started. The easiest place to accomplish this is in a delegator factory \ntargeting the Swoole HTTP server. First, we'll create the delegator factory:  // In src/App/TaskWorkerDelegator.php:\n\nnamespace App;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Server as HttpServer;\n\nclass TaskWorkerDelegator\n{\n    public function __invoke(ContainerInterface $container, $serviceName, callable $callback) : HttpServer\n    {\n        $server = $callback();\n        $logger = $container->get(LoggerInterface::class);\n\n        $server->on('task', $container->get(TaskWorker::class));\n        $server->on('finish', function ($server, $taskId, $data) use ($logger) {\n            $logger->notice('Task #{taskId} has finished processing', ['taskId' => $taskId]);\n        });\n\n        return $server;\n    }\n}  Next, we'll register it with our container:  // In config/autoload/dependencies.php:\n\nreturn [\n    'dependencies' => [\n        'delegators' => [\n            \\Swoole\\Http\\Server::class => [\n                \\App\\TaskWorkerDelegator::class,\n            ],\n        ],\n    ],\n];  With this in place, we can now trigger tasks within our application. In the\nscenario outlined above, the task worker expects  messages ; it then  notifies \nlisteners of that message so they may respond to it.",
            "title": "An example task worker"
        },
        {
            "location": "/v2/async-tasks/#triggering-tasks-in-middleware",
            "text": "Considering that this library provides an application runner for middleware\napplications, you will likely trigger tasks from within your middleware or\nrequest handlers. In each case, you will need to compose the Swoole HTTP server\ninstance as a class dependency, as tasks are triggered via the server via its task()  method. The method can accept any value except a resource as an\nargument.  In the example below,  ContactMessage  will implement the  MessageInterface \nfrom the above example. The request handler uses values from the request to\ncreate the  ContactMessage  instance, and then create a task from it. It then\nimmediately returns a response.  // in src/App/Handler/TaskTriggeringHandler.php:\n\nnamespace App\\Handler;\n\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Swoole\\Http\\Server as HttpServer;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TaskTriggeringHandler implements RequestHandlerInterface\n{\n    private $responseFactory;\n    private $server;\n    private $template;\n\n    public function __construct(\n        HttpServer $server,\n        TemplateRendererInterface $template,\n        ResponseFactoryInterface $responseFactory\n    ) {\n        $this->server          = $server;\n        $this->template        = $template;\n        $this->responseFactory = $responseFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        // Gather data from request\n        $data = $request->getParsedBody();\n\n        // A fictonal event describing a contact request:\n        $event = new ContactEvent([\n            'to'      => $data['email'],\n            'subject' => $data['subject'],\n            'message' => $data['message'],\n        ]);\n\n        // task() returns a task identifier, if you want to use it; otherwise,\n        // you can ignore the return value.\n        $taskIdentifier = $this->server->task($event);\n\n        // The task() method is asynchronous, so execution continues immediately.\n        $response = ($this->responseFactory()->createResponse())\n            ->withHeader('Content-Type', 'text/html');\n        $response->getBody()->write($this->template->render('contact::thank-you', []);\n        return $response;\n    }\n}",
            "title": "Triggering Tasks in Middleware"
        },
        {
            "location": "/v2/hot-code-reload/",
            "text": "Hot Code Reload\n\n\n\n\n\n\nSince 2.3.0\n\n\n\n\n\n\nTo ease development against a running Swoole HTTP server, hot code reloading can\nbe enabled.\n\n\nWith this feature enabled, a Swoole worker will monitor included PHP files using\n\ninotify\n, and will restart all workers if a file is changed, thus mitigating\nthe need to manually restart the server to test changes.\n\n\nThis feature should only be used in your local development environment, and\nshould not be used in production!\n\n\nRequirements\n\n\n\n\next-inotify\n\n\n\n\nThis library ships with an \ninotify\n\nbased implementation of \nZend\\Expressive\\Swoole\\HotCodeReload\\FileWatcherInterface\n.\nIn order to use it, the \ninotify\n extension must be loaded.\n\n\nConfiguration\n\n\nThe following demonstrates all currently available configuration options:\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'hot-code-reload' => [\n            // Set to true to enable hot code reload; the default is false.\n            'enable' => true,\n\n            // Time in milliseconds between checks to changes in files.\n            'interval' => 500,\n        ],\n    ],\n];\n\n\n\nLimitations\n\n\nOnly files included by PHP after \nonWorkerStart\n will be reloaded. This means\nthat Swoole will not reload any of the following:\n\n\n\n\nNew routes\n\n\nNew pipeline middleware\n\n\nThe \nApplication\n instance, \nor any delegators used to modify it\n.\n\n\nThe Swoole HTTP server itself.\n\n\n\n\nThis limitation exists because the hot code reload features use the\n\nSwoole\\Server::reload()\n method to notify Swoole to reload\nPHP files (see \nthe Swoole reload() documentation for more details\n).",
            "title": "Hot Code Reloading"
        },
        {
            "location": "/v2/hot-code-reload/#hot-code-reload",
            "text": "Since 2.3.0    To ease development against a running Swoole HTTP server, hot code reloading can\nbe enabled.  With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating\nthe need to manually restart the server to test changes.  This feature should only be used in your local development environment, and\nshould not be used in production!",
            "title": "Hot Code Reload"
        },
        {
            "location": "/v2/hot-code-reload/#requirements",
            "text": "ext-inotify   This library ships with an  inotify \nbased implementation of  Zend\\Expressive\\Swoole\\HotCodeReload\\FileWatcherInterface .\nIn order to use it, the  inotify  extension must be loaded.",
            "title": "Requirements"
        },
        {
            "location": "/v2/hot-code-reload/#configuration",
            "text": "The following demonstrates all currently available configuration options:  // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'hot-code-reload' => [\n            // Set to true to enable hot code reload; the default is false.\n            'enable' => true,\n\n            // Time in milliseconds between checks to changes in files.\n            'interval' => 500,\n        ],\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/v2/hot-code-reload/#limitations",
            "text": "Only files included by PHP after  onWorkerStart  will be reloaded. This means\nthat Swoole will not reload any of the following:   New routes  New pipeline middleware  The  Application  instance,  or any delegators used to modify it .  The Swoole HTTP server itself.   This limitation exists because the hot code reload features use the Swoole\\Server::reload()  method to notify Swoole to reload\nPHP files (see  the Swoole reload() documentation for more details ).",
            "title": "Limitations"
        },
        {
            "location": "/v2/command-line/",
            "text": "Command Line Tooling\n\n\nThis package ships the vendor binary \nzend-expressive-swoole\n. It provides the\nfollowing commands:\n\n\n\n\nstart\n to start the server\n\n\nstop\n to stop the server (when run in daemonized mode)\n\n\nreload\n to reload the server (when run in daemonized mode)\n\n\nstatus\n to determine the server status (running or not running)\n\n\n\n\nYou may obtain help for each command using the \nhelp\n meta-command:\n\n\n$ ./vendor/bin/zend-expressive-swoole help start\n\n\n\nThe \nstop\n, \nstatus\n, and \nreload\n commands are sufficiently generic to work\nregardless of runtime or application, as they work directly with the Swoole\nprocess manager. The \nstart\n command, however, may need customizations if you\nhave customized your application bootstrap.\n\n\nThe start command\n\n\nThe \nstart\n command will start the web server using the following steps:\n\n\n\n\n\n\nIt pulls the \nSwoole\\Http\\Server\n service from the application dependency\n  injection container, and calls \nset()\n on it with options denoting the number\n  of workers to run (provided via the \n--num-workers\n or \n-w\n option), and\n  whether or not to daemonize the server (provided via the \n--daemonize\n or \n-d\n\n  option).\n\n\n\n\n\n\nIt pulls the \nZend\\Expressive\\Application\n and\n  \nZend\\Expressive\\MiddlewareFactory\n services from the container.\n\n\n\n\n\n\nIt loads the \nconfig/pipeline.php\n and \nconfig/routes.php\n files, invoking\n  their return values with the application, middleware factory, and dependency\n  injection container instances.\n\n\n\n\n\n\nIt calls the \nrun()\n method of the application instance.\n\n\n\n\n\n\nThese are roughly the steps taken within the application bootstrap\n(\npublic/index.php\n) of the Expressive skeleton application.\n\n\nWriting a custom start command\n\n\nIf your application needs alternate bootstrapping (e.g., if you have modified\nthe \npublic/index.php\n, or if you are using this package with a different\nmiddleware runtime), we recommend writing a custom \nstart\n command.\n\n\nAs an example, let's say you have altered your application such that you're\ndefining your routes in multiple files, and instead of:\n\n\n(require 'config/routes.php')($app, $factory, $container);\n\n\n\nyou instead have something like:\n\n\n$handle = opendir('config/routes/');\nwhile (false !== ($entry = readdir($handle))) {\n    if (false === strrpos($entry, '.php')) {\n        continue;\n    }\n    (require $entry)($app, $factory, $container);\n}\n\n\n\nYou could write a command such as the following:\n\n\n// In src/App/Command/StartCommand.php:\n\nnamespace App\\Command;\n\nuse Psr\\Container\\ContainerInterface;\nuse Swoole\\Http\\Server as SwooleHttpServer;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Expressive\\Swoole\\Command\\StartCommand as BaseStartCommand;\nuse Zend\\Expressive\\Swoole\\PidManager;\n\nclass StartCommand extends BaseStartCommand\n{\n    protected function execute(InputInterface $input, OutputInterface $output) : int\n    {\n        // This functionality is identical to the base start command, and should\n        // be copy and pasted to your implementation:\n        $this->pidManager = $this->container->get(PidManager::class);\n        if ($this->isRunning()) {\n            $output->writeln('<error>Server is already running!</error>');\n            return 1;\n        }\n\n        $server = $this->container->get(SwooleHttpServer::class);\n        $server->set([\n            'daemonize' => $input->getOption('daemonize'),\n            'worker_num' => $input->getOption('num-workers') ?? self::DEFAULT_NUM_WORKERS,\n        ]);\n\n        /** @var \\Zend\\Expressive\\Application $app */\n        $app = $this->container->get(Application::class);\n\n        /** @var \\Zend\\Expressive\\MiddlewareFactory $factory */\n        $factory = $this->container->get(MiddlewareFactory::class);\n\n        // Execute programmatic/declarative middleware pipeline and routing\n        // configuration statements\n        (require 'config/pipeline.php')($app, $factory, $this->container);\n\n        //\n        // This is the new code from above:\n        //\n        $handle = opendir(getcwd() . '/config/routes/');\n        while (false !== ($entry = readdir($handle))) {\n            if (false === strrpos($entry, '.php')) {\n                continue;\n            }\n            (require $entry)($app, $factory, $container);\n        }\n\n        // And now we return to the original code:\n\n        // Run the application\n        $app->run();\n\n        return 0;\n    }\n}\n\n\n\nYou will also need to write a factory for the class:\n\n\n// In src/App/Command/StartCommandFactory.php:\n\nnamespace App\\Command;\n\nuse Psr\\Container\\ContainerInterface;\n\nclass StartCommandFactory\n{\n    public function __invoke(ContainerInterface $container) : StartCommand\n    {\n        return new StartCommand($container);\n    }\n}\n\n\n\nIf this is all you're changing, you can map this new command to the existing\n\nZend\\Expressive\\Swoole\\Command\\StartCommand\n service within your configuration:\n\n\n// in config/autoload/dependencies.global.php:\n\nuse App\\Command\\StartCommandFactory;\nuse Zend\\Expressive\\Swoole\\Command\\StartCommand;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            StartCommand::class => StartCommandFactory::class,\n        ],\n    ],\n];\n\n\n\nSince the \nzend-expressive-swoole\n binary uses your application configuration\nand container, this will substitute your command for the shipped command!",
            "title": "Command Line Tooling"
        },
        {
            "location": "/v2/command-line/#command-line-tooling",
            "text": "This package ships the vendor binary  zend-expressive-swoole . It provides the\nfollowing commands:   start  to start the server  stop  to stop the server (when run in daemonized mode)  reload  to reload the server (when run in daemonized mode)  status  to determine the server status (running or not running)   You may obtain help for each command using the  help  meta-command:  $ ./vendor/bin/zend-expressive-swoole help start  The  stop ,  status , and  reload  commands are sufficiently generic to work\nregardless of runtime or application, as they work directly with the Swoole\nprocess manager. The  start  command, however, may need customizations if you\nhave customized your application bootstrap.",
            "title": "Command Line Tooling"
        },
        {
            "location": "/v2/command-line/#the-start-command",
            "text": "The  start  command will start the web server using the following steps:    It pulls the  Swoole\\Http\\Server  service from the application dependency\n  injection container, and calls  set()  on it with options denoting the number\n  of workers to run (provided via the  --num-workers  or  -w  option), and\n  whether or not to daemonize the server (provided via the  --daemonize  or  -d \n  option).    It pulls the  Zend\\Expressive\\Application  and\n   Zend\\Expressive\\MiddlewareFactory  services from the container.    It loads the  config/pipeline.php  and  config/routes.php  files, invoking\n  their return values with the application, middleware factory, and dependency\n  injection container instances.    It calls the  run()  method of the application instance.    These are roughly the steps taken within the application bootstrap\n( public/index.php ) of the Expressive skeleton application.",
            "title": "The start command"
        },
        {
            "location": "/v2/command-line/#writing-a-custom-start-command",
            "text": "If your application needs alternate bootstrapping (e.g., if you have modified\nthe  public/index.php , or if you are using this package with a different\nmiddleware runtime), we recommend writing a custom  start  command.  As an example, let's say you have altered your application such that you're\ndefining your routes in multiple files, and instead of:  (require 'config/routes.php')($app, $factory, $container);  you instead have something like:  $handle = opendir('config/routes/');\nwhile (false !== ($entry = readdir($handle))) {\n    if (false === strrpos($entry, '.php')) {\n        continue;\n    }\n    (require $entry)($app, $factory, $container);\n}  You could write a command such as the following:  // In src/App/Command/StartCommand.php:\n\nnamespace App\\Command;\n\nuse Psr\\Container\\ContainerInterface;\nuse Swoole\\Http\\Server as SwooleHttpServer;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Expressive\\Swoole\\Command\\StartCommand as BaseStartCommand;\nuse Zend\\Expressive\\Swoole\\PidManager;\n\nclass StartCommand extends BaseStartCommand\n{\n    protected function execute(InputInterface $input, OutputInterface $output) : int\n    {\n        // This functionality is identical to the base start command, and should\n        // be copy and pasted to your implementation:\n        $this->pidManager = $this->container->get(PidManager::class);\n        if ($this->isRunning()) {\n            $output->writeln('<error>Server is already running!</error>');\n            return 1;\n        }\n\n        $server = $this->container->get(SwooleHttpServer::class);\n        $server->set([\n            'daemonize' => $input->getOption('daemonize'),\n            'worker_num' => $input->getOption('num-workers') ?? self::DEFAULT_NUM_WORKERS,\n        ]);\n\n        /** @var \\Zend\\Expressive\\Application $app */\n        $app = $this->container->get(Application::class);\n\n        /** @var \\Zend\\Expressive\\MiddlewareFactory $factory */\n        $factory = $this->container->get(MiddlewareFactory::class);\n\n        // Execute programmatic/declarative middleware pipeline and routing\n        // configuration statements\n        (require 'config/pipeline.php')($app, $factory, $this->container);\n\n        //\n        // This is the new code from above:\n        //\n        $handle = opendir(getcwd() . '/config/routes/');\n        while (false !== ($entry = readdir($handle))) {\n            if (false === strrpos($entry, '.php')) {\n                continue;\n            }\n            (require $entry)($app, $factory, $container);\n        }\n\n        // And now we return to the original code:\n\n        // Run the application\n        $app->run();\n\n        return 0;\n    }\n}  You will also need to write a factory for the class:  // In src/App/Command/StartCommandFactory.php:\n\nnamespace App\\Command;\n\nuse Psr\\Container\\ContainerInterface;\n\nclass StartCommandFactory\n{\n    public function __invoke(ContainerInterface $container) : StartCommand\n    {\n        return new StartCommand($container);\n    }\n}  If this is all you're changing, you can map this new command to the existing Zend\\Expressive\\Swoole\\Command\\StartCommand  service within your configuration:  // in config/autoload/dependencies.global.php:\n\nuse App\\Command\\StartCommandFactory;\nuse Zend\\Expressive\\Swoole\\Command\\StartCommand;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            StartCommand::class => StartCommandFactory::class,\n        ],\n    ],\n];  Since the  zend-expressive-swoole  binary uses your application configuration\nand container, this will substitute your command for the shipped command!",
            "title": "Writing a custom start command"
        },
        {
            "location": "/v2/how-it-works/",
            "text": "How it works\n\n\nWhen you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface, \nwithout using a web server\n.\n\n\nThis sounds a bit strange in PHP, though it will be familiar to \nNode.js\n\ndevelopers; the execution model under Swoole is similar to that technology.\n\n\nThe HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the \non(string $name, callable $action)\n method.\n\n\nThe request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the \non('request')\n\nevent of \nSwoole\\Http\\Server\n. This runner is implemented in the\n\nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n class.\n\n\nThe basic implementation acts similar to the following:\n\n\npublic function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}\n\n\n\nThis package provides a bridge between \nSwoole\\Http\\Request\n (\n$request\n) and\n\nPSR-7\n requests (\n$psr7Request\n;\nspecifically as implemented by \nzend-diactoros\n)\nvia the class \nZend\\Expressive\\Swoole\\ServerRequestSwooleFactory\n.\n\n\nIt also provides a Swoole-specific emitter, \nZend\\Expressive\\Swoole\\SwooleEmitter\n,\nthat converts a PSR-7 response to a \nSwoole\\Http\\Response\n instance.\n\n\nWhen you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4 \nworker\n\n(or \nreactor\n) processes and 1 \nmaster\n process, for a total of 5 PHP processes.\n\n\n\n\nThe advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.\n\n\nPerformance\n\n\nThe ZF developers performed a benchmark running the default \nzend-expressive-skeleton\n\napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.\n\n\nThe results demonstrated that \nExpressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache\n.\n\n\nThis impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.\n\n\nUnder Swoole 4.1+, for even better performance, you can enable the option\n\nzend-expressive-swoole.enable_coroutine\n. When this\nis enabled, Swoole will run most I/O processes in coroutines. Doing so provides\napproximately \n10 times faster performance\n than without coroutines, meaning a\nSwoole-based application can be 40 to 50 times faster than running under nginx\nor Apache. Performance improves with the number of workers (which are restricted\nby the amount of memory); as such, performance can increase from these numbers.",
            "title": "How it works"
        },
        {
            "location": "/v2/how-it-works/#how-it-works",
            "text": "When you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface,  without using a web server .  This sounds a bit strange in PHP, though it will be familiar to  Node.js \ndevelopers; the execution model under Swoole is similar to that technology.  The HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the  on(string $name, callable $action)  method.  The request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the  on('request') \nevent of  Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner  class.  The basic implementation acts similar to the following:  public function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}  This package provides a bridge between  Swoole\\Http\\Request  ( $request ) and PSR-7  requests ( $psr7Request ;\nspecifically as implemented by  zend-diactoros )\nvia the class  Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory .  It also provides a Swoole-specific emitter,  Zend\\Expressive\\Swoole\\SwooleEmitter ,\nthat converts a PSR-7 response to a  Swoole\\Http\\Response  instance.  When you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4  worker \n(or  reactor ) processes and 1  master  process, for a total of 5 PHP processes.   The advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.",
            "title": "How it works"
        },
        {
            "location": "/v2/how-it-works/#performance",
            "text": "The ZF developers performed a benchmark running the default  zend-expressive-skeleton \napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.  The results demonstrated that  Expressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache .  This impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.  Under Swoole 4.1+, for even better performance, you can enable the option zend-expressive-swoole.enable_coroutine . When this\nis enabled, Swoole will run most I/O processes in coroutines. Doing so provides\napproximately  10 times faster performance  than without coroutines, meaning a\nSwoole-based application can be 40 to 50 times faster than running under nginx\nor Apache. Performance improves with the number of workers (which are restricted\nby the amount of memory); as such, performance can increase from these numbers.",
            "title": "Performance"
        },
        {
            "location": "/v2/considerations/",
            "text": "Considerations when using Swoole\n\n\nBecause Swoole uses an event loop, and because it is able to load your\napplication exactly once, you must take several precautions when using it to\nserve your application.\n\n\nLong-running processes\n\n\nWhen using the Swoole HTTP server, your application runs within an \nevent\nloop\n. One benefit of this is that you\ncan then \ndefer\n\nexecution of code until the next tick of the loop. This can be used to delay\nlong-running code from executing until after a response has been sent to the\nclient, which can obviate the need for tools such as message queues.\n\n\nThe problem, however, is that when a worker \ndoes\n begin to handle the deferred\nfunctionality, it will run as long as needed until the work is done. This then\nmeans that the worker is \nblocked\n from handling new requests until that work is\ndone.\n\n\nIf you have enough workers, or the number of such long-running processes if few\nand far-between, this may not be an issue for you. However, it is a commonly\ndocumented issue in other similar systems such as Node.js. \nThe solution in these\ncases is the same as for general PHP applications: add a message queue to your\nsystems infrastructure, and delegate such work to the message queue instead.\n\n\n\n\nPDO Coroutine Support\n\n\nPlease be aware that enabling coroutine support with \nSwoole\\Runtime::enableCoroutine()\n\nonly decorates MySql PDO connections with coroutines; other drivers (e.g.,\npdo_pgsql) remain blocking as of Swoole 4.1.2. For more details,\n\nvisit the related bug report on the Swoole issue tracker\n.\n\n\n\n\nSessions\n\n\nBecause Swoole runs as a PHP CLI application, it generally does not play well\nwith the PHP Session extension. However, there are alternatives.\n\n\nzend-expressive-session-cache\n\n\nzend-expressive-session-cache\n\nprovides a persistence adapter for \nzend-expressive-session\n\nthat uses a \nPSR-6 CacheItemPoolInterface implementation\n\nfor storing and retrieving sessions. This approach requires that you setup a\nbackend cache storage for your session data.\n\n\npsr7-sessions/storageless\n\n\nPSR7Session\n provides session\nmiddleware that uses \nJWT tokens\n within\nthe session cookie to transmit session data between the server and client.\nThis approach requires no central session storage, but does impose limits on the\namount of information you can store in a session.\n\n\nStateless services\n\n\nThe typical PHP model is that the engine is fired up, runs your code, and then\ntears down again, \nfor every single request\n. As such, PHP is said to have a\n\"shared nothing architecture\". This is a tremendous boon to developers, as they\ncan ignore things found in lower level languages, such as garbage cleanup,\nmemory management, and more.\n\n\nThis model also comes with a cost: every single request requires bootstrapping\nyour application. Benchmarks we have performed show that bootstrapping is often\nthe most expensive operation in applications, often accounting for 25-50% of\ntotal resource usage and execution time.\n\n\nOne reason technologies such as Swoole can provide a performance boost is due to\nthe fact that they can bootstrap your application exactly once, often during\nstartup. This alone can account for the performance boost of many applications.\n\n\nHowever, it has a price: you now need to consider what changes may happen inside\nthe various classes in your dependency injection container, and the impact those\nchanges may have on later requests, or even other requests happening\nconcurrently.\n\n\nAs one example: \nzend-expressive-template\n\nprovides an interface, \nTemplateRendererInterface\n, that allows you to render a\ntemplate. That interface also allows you to provide template paths, and default\nparameters to pass to every template, and these methods are often invoked within\nfactories or delegators in order to configure the renderer implementation.\nHowever, we have \nalso documented using \naddDefaultParam()\n for passing values\ndiscovered in the request to later handlers\n.\nThis practice accumulates \nstate\n in the renderer that can cause problems later:\n\n\n\n\n\n\nFlash messages discovered in one request might then be pushed to templates\n  renderered in subsequent requests \u2014 when they are no longer in scope. \n\n\n\n\n\n\nUser details from one request might persist to a template rendered for an\n  unauthenticated user in another request, exposing information.\n\n\n\n\n\n\nThese are clearly problematic behaviors!\n\n\nAs such, you must guard against state in services you provide in your dependency\ninjection container, as any state changes have ramifications for other requests.\nWrite services to be stateless, and/or mark state-changing methods as\n\n@internal\n to prevent users from calling them in non-bootstrap code.\n\n\nIf the services are provided by a third party, you have a few options:\n\n\n\n\n\n\nDecorating an existing service that implements an interface to make it\n  stateless.\n\n\n\n\n\n\nExtending a service to make state-changing methods no-ops.\n\n\n\n\n\n\nInjecting factories that produce the stateful services, instead of the service\n  itself.\n\n\n\n\n\n\nWe'll look at each in detail.\n\n\nDecoration\n\n\nIf a service implements an interface, you can decorate the service to make it\nstateless. Well-written interfaces will be stateless by design, and not provide\nmethods meant to internally change state. In these situations, you can create a\nproxy class that decorates the original service:\n\n\nclass ProxyService implements OriginalInterface\n{\n    /** @var OriginalInterface */\n    private $proxy;\n\n    public function __construct(OriginalInterface $proxy)\n    {\n        $this->proxy = $proxy;\n    }\n\n    public function someMethodDefinedInInterface(string $argument) : Result\n    {\n        return $this->proxy->someMethodDefinedInInterface($argument);\n    }\n}\n\n\n\nYou would then:\n\n\n\n\nMap the factory for the original service to the implementation name.\n\n\nCreate a factory that consumes the original service, and produces the proxy.\n\n\nMap the interface name to the factory that creates the proxy.\n\n\n\n\n// in config/autoload/dependencies.global.php:\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            OriginalImplementation::class => OriginalImplementationFactory::class,\n            OriginalInterface::class => ProxyServiceFactory::class,\n        ],\n    ],\n];\n\n\n\nIf you were writing to the interface, and not the implementation, you can now\nguarantee that any non-interface methods that changed state can now no longer be\ncalled.\n\n\nIf the interface itself defines methods that modify state, we recommend writing\na proxy that implements those methods as no-ops and/or that raises exceptions\nwhen those methods are invoked. (The latter approach ensures that you discover\nquickly when code is exercising those methods.) In each case, you would then use\na \ndelegator factory\n,\nto decorate the original instance in the proxy class:\n\n\nfunction (ContainerInterface $container, string $name, callable $callback)\n{\n    return new ProxyService($callback());\n}\n\n\n\n(You can also use the delegator factory approach with the previous proxy service\nexample.)\n\n\nExtension\n\n\nWhen a service does not implement an interface, but exposes methods that change\ninternal state, you can extend the original class to make the methods that\nchange state into no-ops, or have them raise exceptions. (The latter approach\nensures that you discover quickly when code is exercising those methods.)\n\n\nAs an example, let's say you have a class \nDataMapper\n that defines a method\n\nsetTable()\n in it, and that method would change the database table the mapper\nwould query. This is a potentially bad situation!\n\n\nWe could extend the class as follows:\n\n\nclass StatelessDataMapper extends DataMapper\n{\n    public function setTable(string $table) : void\n    {\n        throw new \\DomainException(sprintf(\n            '%s should not be called in production code!',\n            __METHOD__\n        ));\n    }\n}\n\n\n\nIn your factory that creates an instance of \nDataMapper\n, have it instead return\na \nStatelessDataMapper\n instance, and you're now safe.\n\n\nFactories\n\n\nAnother approach is to modify your consuming code to accept a \nfactory\n that\nwill produce the service you'll consume, instead of the service itself. This\napproach ensures that the service is created only when needed, mitigating any\nstate change issues.\n\n\nAs an example, consider the following middleware that currently consumes a\ntemplate renderer:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var TemplateRendererInterface */\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        return new HtmlResponse($this->renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}\n\n\n\nWhat we will do is modify it to accept a \ncallable\n to the constructor. We will\nthen call that factory \njust before\n we need the renderer; we \nwill not\n store\nthe result in the handler, as we want to ensure we have a new instance each\ntime.\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var callable */\n    private $rendererFactory;\n\n    public function __construct(callable $rendererFactory)\n    {\n        $this->rendererFactory = $rendererFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        /** @var TemplateRendererInterface $renderer */\n        $renderer = ($this->rendererFactory)();\n        return new HtmlResponse($renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}\n\n\n\nFrom here, we create a factory for our dependency injection container that will\nreturn the factory we use here. As an example, if we are using the \nzend-view\nintegration\n,\nwe might do the following:\n\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Expressive\\ZendView\\ZendViewRendererFactory;\n\nclass ZendViewRendererFactoryFactory\n{\n    public function __invoke(ContainerInterface $container) : callable\n    {\n        $factory = new ZendViewRendererFactory();\n        return function () use ($container, $factory) : TemplateRendererInterface {\n            return $factory($container);\n        };\n    }\n}\n\n\n\nIf we mapped this to the \"service\" \nZend\\Expressive\\Template\\TemplateRendererInterfaceFactory\n,\nour factory for the \nSomeHandler\n class would then look like:\n\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory;\n\nfunction (ContainerInterface $container) : SomeHandler\n{\n    return new SomeHandler(\n        $container->get(TemplateRendererInterfaceFactory::class)\n    );\n}\n\n\n\nThis approach ensures we get a new instance with known state at precisely the\nmoment we wish to execute the functionality. By ensuring we \ndo not\n store the\ninstance in any way, we also ensure it is garbage collected when the instance\ngoes out of scope (i.e., when the method ends).\n\n\n\n\nHandling the template data problem\n\n\nIf we want our services to be stateless, how do we handle problems such as the \n\ndocumented \naddDefaultParam()\n issue referenced earlier\n?\n\n\nIn this case, the original problem was \"how do we get common request data into\ntemplates?\" The solution originally provided was to alter the state of the\ntemplate renderer. Another solution, however, is one we've also documented\npreviously: \nuse server attributes to pass data between middleware\n.\n\n\nIn this particular case, the middleware documented in the original solution\ncould be modified to provide data to a request attribute, instead of altering\nthe state of the template renderer. It might then become:\n\n\nnamespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Session\\Authentication\\UserInterface;\nuse Zend\\Expressive\\Session\\Flash\\FlashMessagesInterface;\n\nclass TemplateDefaultsMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $routeResult = $request->getAttribute(RouteResult::class);\n        $flashMessages = $request->getAttribute(FlashMessagesInterface::class);\n\n        $defaults = [\n            // Inject the current user, or null if there isn't one.\n            // This is named security so it will not interfere with your user admin pages\n            'security' => $request->getAttribute(UserInterface::class),\n\n            // Inject the currently matched route name.\n            'matchedRouteName' => $routeResult ? $routeResult->getMatchedRouteName() : null,\n\n            // Inject all flash messages\n            'notifications' => $flashMessages ? $flashMessages->getFlashes() : [],\n        ];\n\n        return $handler->handle($request->withAttribute(__CLASS__, $defaults));\n    }\n}\n\n\n\nOnce that change is made, you would then change your handler to do the\nfollowing:\n\n\n\n\nPull that attribute, providing a default \n[]\n value.\n\n\nMerge the pulled value with any local values when rendering the template.\n\n\n\n\nFor example:\n\n\n$defaultParams = $request->getAttribute(TemplateDefaultsMiddleware::class, []);\nreturn new HtmlResponse($renderer->render(\n    'some::template',\n    array_merge($defaultParams, [\n        // handler-specific parameters here\n    ])\n));\n\n\n\nThis approach, while it requires more work on the part of handler authors,\nensures that the renderer state does not vary between requests, making it\nsafer for usage with Swoole and other long-running processes.",
            "title": "Considerations when using Swoole"
        },
        {
            "location": "/v2/considerations/#considerations-when-using-swoole",
            "text": "Because Swoole uses an event loop, and because it is able to load your\napplication exactly once, you must take several precautions when using it to\nserve your application.",
            "title": "Considerations when using Swoole"
        },
        {
            "location": "/v2/considerations/#long-running-processes",
            "text": "When using the Swoole HTTP server, your application runs within an  event\nloop . One benefit of this is that you\ncan then  defer \nexecution of code until the next tick of the loop. This can be used to delay\nlong-running code from executing until after a response has been sent to the\nclient, which can obviate the need for tools such as message queues.  The problem, however, is that when a worker  does  begin to handle the deferred\nfunctionality, it will run as long as needed until the work is done. This then\nmeans that the worker is  blocked  from handling new requests until that work is\ndone.  If you have enough workers, or the number of such long-running processes if few\nand far-between, this may not be an issue for you. However, it is a commonly\ndocumented issue in other similar systems such as Node.js.  The solution in these\ncases is the same as for general PHP applications: add a message queue to your\nsystems infrastructure, and delegate such work to the message queue instead.",
            "title": "Long-running processes"
        },
        {
            "location": "/v2/considerations/#pdo-coroutine-support",
            "text": "Please be aware that enabling coroutine support with  Swoole\\Runtime::enableCoroutine() \nonly decorates MySql PDO connections with coroutines; other drivers (e.g.,\npdo_pgsql) remain blocking as of Swoole 4.1.2. For more details, visit the related bug report on the Swoole issue tracker .",
            "title": "PDO Coroutine Support"
        },
        {
            "location": "/v2/considerations/#sessions",
            "text": "Because Swoole runs as a PHP CLI application, it generally does not play well\nwith the PHP Session extension. However, there are alternatives.",
            "title": "Sessions"
        },
        {
            "location": "/v2/considerations/#zend-expressive-session-cache",
            "text": "zend-expressive-session-cache \nprovides a persistence adapter for  zend-expressive-session \nthat uses a  PSR-6 CacheItemPoolInterface implementation \nfor storing and retrieving sessions. This approach requires that you setup a\nbackend cache storage for your session data.",
            "title": "zend-expressive-session-cache"
        },
        {
            "location": "/v2/considerations/#psr7-sessionsstorageless",
            "text": "PSR7Session  provides session\nmiddleware that uses  JWT tokens  within\nthe session cookie to transmit session data between the server and client.\nThis approach requires no central session storage, but does impose limits on the\namount of information you can store in a session.",
            "title": "psr7-sessions/storageless"
        },
        {
            "location": "/v2/considerations/#stateless-services",
            "text": "The typical PHP model is that the engine is fired up, runs your code, and then\ntears down again,  for every single request . As such, PHP is said to have a\n\"shared nothing architecture\". This is a tremendous boon to developers, as they\ncan ignore things found in lower level languages, such as garbage cleanup,\nmemory management, and more.  This model also comes with a cost: every single request requires bootstrapping\nyour application. Benchmarks we have performed show that bootstrapping is often\nthe most expensive operation in applications, often accounting for 25-50% of\ntotal resource usage and execution time.  One reason technologies such as Swoole can provide a performance boost is due to\nthe fact that they can bootstrap your application exactly once, often during\nstartup. This alone can account for the performance boost of many applications.  However, it has a price: you now need to consider what changes may happen inside\nthe various classes in your dependency injection container, and the impact those\nchanges may have on later requests, or even other requests happening\nconcurrently.  As one example:  zend-expressive-template \nprovides an interface,  TemplateRendererInterface , that allows you to render a\ntemplate. That interface also allows you to provide template paths, and default\nparameters to pass to every template, and these methods are often invoked within\nfactories or delegators in order to configure the renderer implementation.\nHowever, we have  also documented using  addDefaultParam()  for passing values\ndiscovered in the request to later handlers .\nThis practice accumulates  state  in the renderer that can cause problems later:    Flash messages discovered in one request might then be pushed to templates\n  renderered in subsequent requests \u2014 when they are no longer in scope.     User details from one request might persist to a template rendered for an\n  unauthenticated user in another request, exposing information.    These are clearly problematic behaviors!  As such, you must guard against state in services you provide in your dependency\ninjection container, as any state changes have ramifications for other requests.\nWrite services to be stateless, and/or mark state-changing methods as @internal  to prevent users from calling them in non-bootstrap code.  If the services are provided by a third party, you have a few options:    Decorating an existing service that implements an interface to make it\n  stateless.    Extending a service to make state-changing methods no-ops.    Injecting factories that produce the stateful services, instead of the service\n  itself.    We'll look at each in detail.",
            "title": "Stateless services"
        },
        {
            "location": "/v2/considerations/#decoration",
            "text": "If a service implements an interface, you can decorate the service to make it\nstateless. Well-written interfaces will be stateless by design, and not provide\nmethods meant to internally change state. In these situations, you can create a\nproxy class that decorates the original service:  class ProxyService implements OriginalInterface\n{\n    /** @var OriginalInterface */\n    private $proxy;\n\n    public function __construct(OriginalInterface $proxy)\n    {\n        $this->proxy = $proxy;\n    }\n\n    public function someMethodDefinedInInterface(string $argument) : Result\n    {\n        return $this->proxy->someMethodDefinedInInterface($argument);\n    }\n}  You would then:   Map the factory for the original service to the implementation name.  Create a factory that consumes the original service, and produces the proxy.  Map the interface name to the factory that creates the proxy.   // in config/autoload/dependencies.global.php:\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            OriginalImplementation::class => OriginalImplementationFactory::class,\n            OriginalInterface::class => ProxyServiceFactory::class,\n        ],\n    ],\n];  If you were writing to the interface, and not the implementation, you can now\nguarantee that any non-interface methods that changed state can now no longer be\ncalled.  If the interface itself defines methods that modify state, we recommend writing\na proxy that implements those methods as no-ops and/or that raises exceptions\nwhen those methods are invoked. (The latter approach ensures that you discover\nquickly when code is exercising those methods.) In each case, you would then use\na  delegator factory ,\nto decorate the original instance in the proxy class:  function (ContainerInterface $container, string $name, callable $callback)\n{\n    return new ProxyService($callback());\n}  (You can also use the delegator factory approach with the previous proxy service\nexample.)",
            "title": "Decoration"
        },
        {
            "location": "/v2/considerations/#extension",
            "text": "When a service does not implement an interface, but exposes methods that change\ninternal state, you can extend the original class to make the methods that\nchange state into no-ops, or have them raise exceptions. (The latter approach\nensures that you discover quickly when code is exercising those methods.)  As an example, let's say you have a class  DataMapper  that defines a method setTable()  in it, and that method would change the database table the mapper\nwould query. This is a potentially bad situation!  We could extend the class as follows:  class StatelessDataMapper extends DataMapper\n{\n    public function setTable(string $table) : void\n    {\n        throw new \\DomainException(sprintf(\n            '%s should not be called in production code!',\n            __METHOD__\n        ));\n    }\n}  In your factory that creates an instance of  DataMapper , have it instead return\na  StatelessDataMapper  instance, and you're now safe.",
            "title": "Extension"
        },
        {
            "location": "/v2/considerations/#factories",
            "text": "Another approach is to modify your consuming code to accept a  factory  that\nwill produce the service you'll consume, instead of the service itself. This\napproach ensures that the service is created only when needed, mitigating any\nstate change issues.  As an example, consider the following middleware that currently consumes a\ntemplate renderer:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var TemplateRendererInterface */\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        return new HtmlResponse($this->renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}  What we will do is modify it to accept a  callable  to the constructor. We will\nthen call that factory  just before  we need the renderer; we  will not  store\nthe result in the handler, as we want to ensure we have a new instance each\ntime.  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var callable */\n    private $rendererFactory;\n\n    public function __construct(callable $rendererFactory)\n    {\n        $this->rendererFactory = $rendererFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        /** @var TemplateRendererInterface $renderer */\n        $renderer = ($this->rendererFactory)();\n        return new HtmlResponse($renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}  From here, we create a factory for our dependency injection container that will\nreturn the factory we use here. As an example, if we are using the  zend-view\nintegration ,\nwe might do the following:  \nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Expressive\\ZendView\\ZendViewRendererFactory;\n\nclass ZendViewRendererFactoryFactory\n{\n    public function __invoke(ContainerInterface $container) : callable\n    {\n        $factory = new ZendViewRendererFactory();\n        return function () use ($container, $factory) : TemplateRendererInterface {\n            return $factory($container);\n        };\n    }\n}  If we mapped this to the \"service\"  Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory ,\nour factory for the  SomeHandler  class would then look like:  use Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory;\n\nfunction (ContainerInterface $container) : SomeHandler\n{\n    return new SomeHandler(\n        $container->get(TemplateRendererInterfaceFactory::class)\n    );\n}  This approach ensures we get a new instance with known state at precisely the\nmoment we wish to execute the functionality. By ensuring we  do not  store the\ninstance in any way, we also ensure it is garbage collected when the instance\ngoes out of scope (i.e., when the method ends).",
            "title": "Factories"
        },
        {
            "location": "/v2/considerations/#handling-the-template-data-problem",
            "text": "If we want our services to be stateless, how do we handle problems such as the  documented  addDefaultParam()  issue referenced earlier ?  In this case, the original problem was \"how do we get common request data into\ntemplates?\" The solution originally provided was to alter the state of the\ntemplate renderer. Another solution, however, is one we've also documented\npreviously:  use server attributes to pass data between middleware .  In this particular case, the middleware documented in the original solution\ncould be modified to provide data to a request attribute, instead of altering\nthe state of the template renderer. It might then become:  namespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Session\\Authentication\\UserInterface;\nuse Zend\\Expressive\\Session\\Flash\\FlashMessagesInterface;\n\nclass TemplateDefaultsMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $routeResult = $request->getAttribute(RouteResult::class);\n        $flashMessages = $request->getAttribute(FlashMessagesInterface::class);\n\n        $defaults = [\n            // Inject the current user, or null if there isn't one.\n            // This is named security so it will not interfere with your user admin pages\n            'security' => $request->getAttribute(UserInterface::class),\n\n            // Inject the currently matched route name.\n            'matchedRouteName' => $routeResult ? $routeResult->getMatchedRouteName() : null,\n\n            // Inject all flash messages\n            'notifications' => $flashMessages ? $flashMessages->getFlashes() : [],\n        ];\n\n        return $handler->handle($request->withAttribute(__CLASS__, $defaults));\n    }\n}  Once that change is made, you would then change your handler to do the\nfollowing:   Pull that attribute, providing a default  []  value.  Merge the pulled value with any local values when rendering the template.   For example:  $defaultParams = $request->getAttribute(TemplateDefaultsMiddleware::class, []);\nreturn new HtmlResponse($renderer->render(\n    'some::template',\n    array_merge($defaultParams, [\n        // handler-specific parameters here\n    ])\n));  This approach, while it requires more work on the part of handler authors,\nensures that the renderer state does not vary between requests, making it\nsafer for usage with Swoole and other long-running processes.",
            "title": "Handling the template data problem"
        },
        {
            "location": "/v2/migration/",
            "text": "Migration\n\n\nThis document covers changes between version 1 and version 2, and how you may\nupdate your code to adapt to them.\n\n\nControlling the server\n\n\nIn version 1, you would execute the web server via the entry script, e.g.:\n\n\n$ php public/index.php start\n\n\n\nWith version 2, we ship the command line tools for controlling your server via\nthe binary \nzend-expressive-swoole\n:\n\n\n# Start the server:\n$ ./vendor/bin/zend-expressive-swoole start -d\n# Reload the server:\n$ ./vendor/bin/zend-expressive-swoole reload\n# Stop the server:\n$ ./vendor/bin/zend-expressive-swoole stop\n\n\n\nWhile you can still call \nphp public/index.php\n, you cannot daemonize the server\nusing that command, nor reload or stop it (other than using \nCtrl-C\n). You will\nneed to change any deployment commands you currently use to consume the new\ncommand line tooling.\n\n\nCoroutine support\n\n\nIn version 1, to enable Swoole's coroutine support, you were expected to pass a\nboolean true value to the\n\nzend-expressive-swoole.swoole-http-server.options.enable_coroutine\n flag.\n\n\nThat flag now controls specifically the HTTP server coroutine support, and\ndefaults to \ntrue\n. To set system-wide coroutine support, toggle the\n\nzend-expressive-swoole.enable_coroutine\n flag, which defaults to boolean false:\n\n\nreturn [\n    'zend-expressive-swoole' => [\n        'enable_coroutine' => false, // system-wide support\n        'swoole-http-server' => [\n            'options' => [\n                'enable_coroutine' => true, // HTTP server coroutine support\n            ],\n        ],\n    ]\n];\n\n\n\nServerFactory\n\n\nVersion 2 refactors the architecture slightly to allow providing the HTTP server\nas a service, which allows us to \nenable async task workers\n.\n\n\nThe primary changes to enable this are:\n\n\n\n\nZend\\Expressive\\Swoole\\ServerFactory\n and its associated service was removed.\n\n\nZend\\Expressive\\Swoole\\ServerFactoryFactory\n was removed.\n\n\nZend\\Expressive\\Swoole\\HttpServerFactory\n was created.\n\n\nThe service \nSwoole\\Http\\Server\n was added, pointing to\n  \nZend\\Expressive\\Swoole\\HttpServerFactory\n.\n\n\nThe constructor for \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n was\n  modified. Previously, the fifth argument was typehinted against the former\n  \nServerFactory\n; it now typehints against \nSwoole\\Http\\Server\n. The factory\n  for this class was modified to pass the correct service.\n\n\n\n\nThese changes should only affect users who were providing service substitutions\nor extending the affected classes.",
            "title": "Migration"
        },
        {
            "location": "/v2/migration/#migration",
            "text": "This document covers changes between version 1 and version 2, and how you may\nupdate your code to adapt to them.",
            "title": "Migration"
        },
        {
            "location": "/v2/migration/#controlling-the-server",
            "text": "In version 1, you would execute the web server via the entry script, e.g.:  $ php public/index.php start  With version 2, we ship the command line tools for controlling your server via\nthe binary  zend-expressive-swoole :  # Start the server:\n$ ./vendor/bin/zend-expressive-swoole start -d\n# Reload the server:\n$ ./vendor/bin/zend-expressive-swoole reload\n# Stop the server:\n$ ./vendor/bin/zend-expressive-swoole stop  While you can still call  php public/index.php , you cannot daemonize the server\nusing that command, nor reload or stop it (other than using  Ctrl-C ). You will\nneed to change any deployment commands you currently use to consume the new\ncommand line tooling.",
            "title": "Controlling the server"
        },
        {
            "location": "/v2/migration/#coroutine-support",
            "text": "In version 1, to enable Swoole's coroutine support, you were expected to pass a\nboolean true value to the zend-expressive-swoole.swoole-http-server.options.enable_coroutine  flag.  That flag now controls specifically the HTTP server coroutine support, and\ndefaults to  true . To set system-wide coroutine support, toggle the zend-expressive-swoole.enable_coroutine  flag, which defaults to boolean false:  return [\n    'zend-expressive-swoole' => [\n        'enable_coroutine' => false, // system-wide support\n        'swoole-http-server' => [\n            'options' => [\n                'enable_coroutine' => true, // HTTP server coroutine support\n            ],\n        ],\n    ]\n];",
            "title": "Coroutine support"
        },
        {
            "location": "/v2/migration/#serverfactory",
            "text": "Version 2 refactors the architecture slightly to allow providing the HTTP server\nas a service, which allows us to  enable async task workers .  The primary changes to enable this are:   Zend\\Expressive\\Swoole\\ServerFactory  and its associated service was removed.  Zend\\Expressive\\Swoole\\ServerFactoryFactory  was removed.  Zend\\Expressive\\Swoole\\HttpServerFactory  was created.  The service  Swoole\\Http\\Server  was added, pointing to\n   Zend\\Expressive\\Swoole\\HttpServerFactory .  The constructor for  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner  was\n  modified. Previously, the fifth argument was typehinted against the former\n   ServerFactory ; it now typehints against  Swoole\\Http\\Server . The factory\n  for this class was modified to pass the correct service.   These changes should only affect users who were providing service substitutions\nor extending the affected classes.",
            "title": "ServerFactory"
        },
        {
            "location": "/v1/intro/",
            "text": "Swoole\n\n\nSwoole\n is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.\n\n\nInstall swoole\n\n\nYou can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:\n\n\n$ pecl install swoole\n\n\n\nFor more information on the extension, \nvisit its package details on PECL\n.\n\n\nInstall zend-expressive-swoole\n\n\nTo install this package, use \nComposer\n:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nSwoole with Expressive\n\n\nzend-expressive-swoole enables an Expressive application to be executed with\nthe \nSwoole\n extension. This means you can run the\napplication from the command line, \nwithout requiring a web server\n.\n\n\nYou can run the application using the following command:\n\n\n$ php public/index.php\n\n\n\nThis command will execute Swoole on \nlocalhost\n via port \n8080\n.\n\n\n\n\nExpressive skeleton versions prior to 3.1.0\n\n\nThe above will work immediately after installing zend-expressive-swoole if you\nare using a version of \nzend-expressive-skeleton\n\nfrom 3.1.0 or later.\n\n\nFor applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as \nconfig/autoload/zend-expressive-swoole.global.php\n\nor \nconfig/autoload/zend-expressive-swoole.local.php\n with the following\ncontents:\n\n\n<?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();\n\n\n\n\n\nYou can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:\n\n\n// In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];\n\n\n\nProviding additional Swoole configuration\n\n\nYou can also configure the Swoole HTTP server using an \noptions\n key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:\n\n\n// config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS;\n                                   // SWOOLE_BASE is the default\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server\n            'options' => [\n                // Set the SSL certificate and key paths for SSL support:\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n                // Available in Swoole 4.1 and up; enables coroutine support\n                // for most I/O operations:\n                'enable_coroutine' => true,\n            ],\n        ],\n    ],\n];\n\n\n\nServing static files\n\n\nWe support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant \nZend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\nOur static resource capabilities are fairly comprehensive; please see the\n\nchapter on static resources\n for full details on\nconfiguration.",
            "title": "Intro"
        },
        {
            "location": "/v1/intro/#swoole",
            "text": "Swoole  is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.",
            "title": "Swoole"
        },
        {
            "location": "/v1/intro/#install-swoole",
            "text": "You can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:  $ pecl install swoole  For more information on the extension,  visit its package details on PECL .",
            "title": "Install swoole"
        },
        {
            "location": "/v1/intro/#install-zend-expressive-swoole",
            "text": "To install this package, use  Composer :  $ composer require zendframework/zend-expressive-swoole",
            "title": "Install zend-expressive-swoole"
        },
        {
            "location": "/v1/intro/#swoole-with-expressive",
            "text": "zend-expressive-swoole enables an Expressive application to be executed with\nthe  Swoole  extension. This means you can run the\napplication from the command line,  without requiring a web server .  You can run the application using the following command:  $ php public/index.php  This command will execute Swoole on  localhost  via port  8080 .",
            "title": "Swoole with Expressive"
        },
        {
            "location": "/v1/intro/#expressive-skeleton-versions-prior-to-310",
            "text": "The above will work immediately after installing zend-expressive-swoole if you\nare using a version of  zend-expressive-skeleton \nfrom 3.1.0 or later.  For applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as  config/autoload/zend-expressive-swoole.global.php \nor  config/autoload/zend-expressive-swoole.local.php  with the following\ncontents:  <?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();   You can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:  // In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];",
            "title": "Expressive skeleton versions prior to 3.1.0"
        },
        {
            "location": "/v1/intro/#providing-additional-swoole-configuration",
            "text": "You can also configure the Swoole HTTP server using an  options  key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:  // config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS;\n                                   // SWOOLE_BASE is the default\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server\n            'options' => [\n                // Set the SSL certificate and key paths for SSL support:\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n                // Available in Swoole 4.1 and up; enables coroutine support\n                // for most I/O operations:\n                'enable_coroutine' => true,\n            ],\n        ],\n    ],\n];",
            "title": "Providing additional Swoole configuration"
        },
        {
            "location": "/v1/intro/#serving-static-files",
            "text": "We support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant  Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .\nOur static resource capabilities are fairly comprehensive; please see the chapter on static resources  for full details on\nconfiguration.",
            "title": "Serving static files"
        },
        {
            "location": "/v1/static-resources/",
            "text": "Static Resources\n\n\nOne feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.\n\n\nTo enable this, the package provides an alternate\n\nRequestHandlerRunner\n\nimplementation via the class \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n\nthat performs two duties:\n\n\n\n\nIf a static resource is matched, it serves that.\n\n\nOtherwise, it passes off handling to the composed application pipeline.\n\n\n\n\nInternally, the \nSwooleRequestHandlerRunner\n composes another class, a \n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n instance. This instance\nis passed the Swoole request and response, and returns a value indicating\nwhether or not it was able to identify and serve a matching static resource.\n\n\nOur default implementation, \nZend\\Expressive\\Swoole\\StaticResourceHandler\n,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.\n\n\nMiddleware\n\n\nThe \nStaticResourceHandler\n implementation performs its work by composing a\nqueue of middleware to execute when attempting to serve a matched file. Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:\n\n\n\n\n\n\nCacheControlMiddleware\n will set a \nCache-Control\n header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the \nCache-Control\n directive to\n  use when the match occurs.\n\n\n\n\n\n\nClearStatCacheMiddleware\n will, if configured to do so, call\n  \nclearstatcache()\n either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.\n\n\n\n\n\n\nContentTypeFilterMiddleware\n checks the incoming filename against a map of\n  known extensions and their associated Content-Type values. If it cannot\n  match the file, it returns a value indicating no match was found so that the\n  application can continue processing the request. Otherwise, it provides the\n  Content-Type for the associated response. This middleware is generally best\n  used as the outermost layer, to ensure no other middleware executes in the\n  case that the file cannot be matched.\n\n\n\n\n\n\nETagMiddleware\n will set an \nETag\n header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the \nETag\n\n  header value matches either an \nIf-Match\n or \nIf-None-Match\n request header,\n  it will provide a response status of \n304\n and disable sending content.\n\n\n\n\n\n\nGzipMiddleware\n detects the \nAccept-Encoding\n request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.\n\n\n\n\n\n\nHeadMiddleware\n will force an empty response. (The status and headers may be\n  set by other middleware.)\n\n\n\n\n\n\nLastModifiedMiddleware\n will set a \nLast-Modified\n header using the\n  \nfilemtime()\n value of the requested resource. If the header value is later\n  than an \nIf-Modified-Since\n  request header, it will provide a response status\n  of \n304\n and disable sending content.\n\n\n\n\n\n\nMethodNotAllowedMiddleware\n will set the response status to \n405\n, and set an\n  \nAllow\n header indicating the allowed methods when an unsupported request\n  method is provided.\n\n\n\n\n\n\nOptionsMiddleware\n will force an empty response with an \nAllow\n header set\n  to the allowed methods. (Other headers may also be present!)\n\n\n\n\n\n\nBy default, these are registered in the following order, contingent on\nconfiguration being provided:\n\n\n\n\nContentTypeFilterMiddleware\n\n\nMethodNotAllowedMiddleware\n\n\nOptionsMiddleware\n\n\nHeadMiddleware\n\n\nGzipMiddleware\n\n\nClearStatCacheMiddleware\n\n\nCacheControlMiddleware\n\n\nLastModifiedMiddleware\n\n\nETagMiddleware\n\n\n\n\nThis approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the \nLast-Modified\n or \nETag\n headers); it also\nensures that all possible headers are provided whenever possible (e.g., a \nHEAD\n\nrequest should also expose \nCache-Control\n, \nLast-Modified\n, and \nETag\n\nheaders).\n\n\n\n\nProviding your own middleware\n\n\nIf you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate\n\nStaticResourceHandler\n factory. In most cases, you can extend\n\nStaticResourceHandlerFactory\n and override the \nconfigureMiddleware(array\n$config) : array\n method to do so. Be sure to remember to add a \ndependencies\n\nsetting mapping the \nStaticResourceHandlerInterface\n service to your new factory\nwhen done!\n\n\n\n\nConfiguration\n\n\nWe provide a factory for the \nStaticResourceHandler\n that uses a\nconfiguration-driven approach in order to:\n\n\n\n\nSet the document root.\n\n\nSet the map of allowed extensions to content-types.\n\n\nConfigure and provide middleware.\n\n\n\n\nThe following demonstrates all currently available configuration options:\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nSecurity warning\n\n\nNever add \nphp\n as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!\n\n\nDocument root\n\n\nIf no \ndocument_root\n configuration is present, the default is to use\n\ngetcwd() . '/public'\n. If either the configured or default document root\ndoes not exist, we raise an exception.\n\n\nDefault extension/content-types\n\n\nBy default, we serve files with extensions in the whitelist defined in the\nconstant \nZend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\n\n\n\n\nConfiguration Example\n\n\nThe example which follows provides the following options:\n\n\n\n\nSets the document root to \n/var/www/htdocs\n.\n\n\nAdds a custom extension / content-type map.\n\n\nProvides a clearstatcache interval of 2 hours.\n\n\nSelects the \"strong\" ETag algorithm.\n\n\nIndicates a gzip compression level of 3.\n\n\nSets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.\n\n\nSets Cache-Control directives for plain text files.\n\n\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nWriting Middleware\n\n\nStatic resource middleware must implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface\n, which\ndefines the following:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}\n\n\n\nThe \n$next\n argument has the following signature:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;\n\n\n\nTypically, middleware will look something like this:\n\n\n$response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.\n\n\n\nMiddleware either produces or manipulates a\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse\n instance.\nThat class looks like the following:\n\n\nclass StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * Call this method to indicate that the request cannot be served as a\n     * static resource. The request runner will then proceed to execute\n     * the associated application in order to generate the response.\n     */\n    public function markAsFailure() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    /**\n     * Use this within a response content callback to set the associated\n     * Content-Length of the generated response. Loggers can then query\n     * for this information in order to provide that information in the logs.\n     */\n    public function setContentLength(int $length) : void;\n\n    public function setStatus(int $status) : void;\n}\n\n\n\nMost middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via \ndisableContent()\n).\nMiddleware that restricts access or filters out specific files will also use\n\nmarkAsFailure()\n.\n\n\n\n\nProviding an alternative mechanism for sending response content\n\n\nIn some cases, you may want to alter how the \nSwoole\\Http\\Response\n receives the\nbody content. By default, we use \nSwoole\\Http\\Response::sendfile()\n. However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the \nGzipMiddleware\n adds a compression filter to\na filehandle representing the file to send, and then calls\n\nSwoole\\Http\\Response::write()\n in a loop until all content is sent.\n\n\nTo perform work like this, you can call the\n\nStaticResourceResponse::setResponseContentCallback()\n method as detailed in the\nsection above within your middleware.\n\n\n\n\nAlternative static resource handlers\n\n\nAs noted at the beginning of this chapter, the \nSwooleRequestHandlerRunner\n\ncomposes a \nStaticResourceHandlerInterface\n instance in order to determine if a\nresource was matched by the request, and then to serve it.\n\n\nIf you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n:\n\n\ndeclare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Attempt to process a static resource based on the current request.\n     *\n     * If the resource cannot be processed, the method should return null.\n     * Otherwise, it should return the StaticResourceResponse that was used\n     * to send the Swoole response instance. The runner can then query this\n     * for content length and status.\n     */\n    public function processStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : ?StaticResourceHandler\\StaticResourceResponse;\n}\n\n\n\nOnce implemented, map the service\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n to a factory that\nreturns your custom implementation within your \ndependencies\n configuration.",
            "title": "Static Resources"
        },
        {
            "location": "/v1/static-resources/#static-resources",
            "text": "One feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.  To enable this, the package provides an alternate RequestHandlerRunner \nimplementation via the class  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner \nthat performs two duties:   If a static resource is matched, it serves that.  Otherwise, it passes off handling to the composed application pipeline.   Internally, the  SwooleRequestHandlerRunner  composes another class, a  Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  instance. This instance\nis passed the Swoole request and response, and returns a value indicating\nwhether or not it was able to identify and serve a matching static resource.  Our default implementation,  Zend\\Expressive\\Swoole\\StaticResourceHandler ,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.",
            "title": "Static Resources"
        },
        {
            "location": "/v1/static-resources/#middleware",
            "text": "The  StaticResourceHandler  implementation performs its work by composing a\nqueue of middleware to execute when attempting to serve a matched file. Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:    CacheControlMiddleware  will set a  Cache-Control  header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the  Cache-Control  directive to\n  use when the match occurs.    ClearStatCacheMiddleware  will, if configured to do so, call\n   clearstatcache()  either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.    ContentTypeFilterMiddleware  checks the incoming filename against a map of\n  known extensions and their associated Content-Type values. If it cannot\n  match the file, it returns a value indicating no match was found so that the\n  application can continue processing the request. Otherwise, it provides the\n  Content-Type for the associated response. This middleware is generally best\n  used as the outermost layer, to ensure no other middleware executes in the\n  case that the file cannot be matched.    ETagMiddleware  will set an  ETag  header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the  ETag \n  header value matches either an  If-Match  or  If-None-Match  request header,\n  it will provide a response status of  304  and disable sending content.    GzipMiddleware  detects the  Accept-Encoding  request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.    HeadMiddleware  will force an empty response. (The status and headers may be\n  set by other middleware.)    LastModifiedMiddleware  will set a  Last-Modified  header using the\n   filemtime()  value of the requested resource. If the header value is later\n  than an  If-Modified-Since   request header, it will provide a response status\n  of  304  and disable sending content.    MethodNotAllowedMiddleware  will set the response status to  405 , and set an\n   Allow  header indicating the allowed methods when an unsupported request\n  method is provided.    OptionsMiddleware  will force an empty response with an  Allow  header set\n  to the allowed methods. (Other headers may also be present!)    By default, these are registered in the following order, contingent on\nconfiguration being provided:   ContentTypeFilterMiddleware  MethodNotAllowedMiddleware  OptionsMiddleware  HeadMiddleware  GzipMiddleware  ClearStatCacheMiddleware  CacheControlMiddleware  LastModifiedMiddleware  ETagMiddleware   This approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the  Last-Modified  or  ETag  headers); it also\nensures that all possible headers are provided whenever possible (e.g., a  HEAD \nrequest should also expose  Cache-Control ,  Last-Modified , and  ETag \nheaders).",
            "title": "Middleware"
        },
        {
            "location": "/v1/static-resources/#providing-your-own-middleware",
            "text": "If you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate StaticResourceHandler  factory. In most cases, you can extend StaticResourceHandlerFactory  and override the  configureMiddleware(array\n$config) : array  method to do so. Be sure to remember to add a  dependencies \nsetting mapping the  StaticResourceHandlerInterface  service to your new factory\nwhen done!",
            "title": "Providing your own middleware"
        },
        {
            "location": "/v1/static-resources/#configuration",
            "text": "We provide a factory for the  StaticResourceHandler  that uses a\nconfiguration-driven approach in order to:   Set the document root.  Set the map of allowed extensions to content-types.  Configure and provide middleware.   The following demonstrates all currently available configuration options:  // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/v1/static-resources/#security-warning",
            "text": "Never add  php  as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!",
            "title": "Security warning"
        },
        {
            "location": "/v1/static-resources/#document-root",
            "text": "If no  document_root  configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root\ndoes not exist, we raise an exception.",
            "title": "Document root"
        },
        {
            "location": "/v1/static-resources/#default-extensioncontent-types",
            "text": "By default, we serve files with extensions in the whitelist defined in the\nconstant  Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .",
            "title": "Default extension/content-types"
        },
        {
            "location": "/v1/static-resources/#configuration-example",
            "text": "The example which follows provides the following options:   Sets the document root to  /var/www/htdocs .  Adds a custom extension / content-type map.  Provides a clearstatcache interval of 2 hours.  Selects the \"strong\" ETag algorithm.  Indicates a gzip compression level of 3.  Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.  Sets Cache-Control directives for plain text files.   // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration Example"
        },
        {
            "location": "/v1/static-resources/#writing-middleware",
            "text": "Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which\ndefines the following:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}  The  $next  argument has the following signature:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;  Typically, middleware will look something like this:  $response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.  Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse  instance.\nThat class looks like the following:  class StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * Call this method to indicate that the request cannot be served as a\n     * static resource. The request runner will then proceed to execute\n     * the associated application in order to generate the response.\n     */\n    public function markAsFailure() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    /**\n     * Use this within a response content callback to set the associated\n     * Content-Length of the generated response. Loggers can then query\n     * for this information in order to provide that information in the logs.\n     */\n    public function setContentLength(int $length) : void;\n\n    public function setStatus(int $status) : void;\n}  Most middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via  disableContent() ).\nMiddleware that restricts access or filters out specific files will also use markAsFailure() .",
            "title": "Writing Middleware"
        },
        {
            "location": "/v1/static-resources/#providing-an-alternative-mechanism-for-sending-response-content",
            "text": "In some cases, you may want to alter how the  Swoole\\Http\\Response  receives the\nbody content. By default, we use  Swoole\\Http\\Response::sendfile() . However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the  GzipMiddleware  adds a compression filter to\na filehandle representing the file to send, and then calls Swoole\\Http\\Response::write()  in a loop until all content is sent.  To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback()  method as detailed in the\nsection above within your middleware.",
            "title": "Providing an alternative mechanism for sending response content"
        },
        {
            "location": "/v1/static-resources/#alternative-static-resource-handlers",
            "text": "As noted at the beginning of this chapter, the  SwooleRequestHandlerRunner \ncomposes a  StaticResourceHandlerInterface  instance in order to determine if a\nresource was matched by the request, and then to serve it.  If you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface :  declare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Attempt to process a static resource based on the current request.\n     *\n     * If the resource cannot be processed, the method should return null.\n     * Otherwise, it should return the StaticResourceResponse that was used\n     * to send the Swoole response instance. The runner can then query this\n     * for content length and status.\n     */\n    public function processStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : ?StaticResourceHandler\\StaticResourceResponse;\n}  Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  to a factory that\nreturns your custom implementation within your  dependencies  configuration.",
            "title": "Alternative static resource handlers"
        },
        {
            "location": "/v1/logging/",
            "text": "Logging\n\n\nWeb servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.\n\n\nOut-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.\n\n\nWe log a number of items:\n\n\n\n\nWhen the web server starts, indicating the host and port on which it is running.\n\n\nWhen workers start, including the working directory and worker ID.\n\n\nWhen the web server stops.\n\n\nWhen the web server reloads workers.\n\n\nEach request (more on this below)\n\n\n\n\nBy default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any \nPSR-3 compliant logger\n to\nlog application details. We emit logs detailing server operations using the\npriority \nPsr\\Log\\LogLevel::NOTICE\n (unless detailing an error, such as\ninability to reload)), while \nPsr\\Log\\LogLevel::INFO\n and \nPsr\\Log\\LogLevel::ERROR\n\nare used to log requests (errors are used for response statuses greater than or\nequal to 400).\n\n\nAccess Logs\n\n\nTechnically, the \nSwooleRequestHandlerRunner\n doesn't use PSR-3 loggers\ndirectly, but, rather, instances of \nZend\\Expressive\\Swoole\\Log\\AccessLogInterface\n.\nThis package-specific interface extends the PSR-3 interface to add two methods:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Request;\nuse Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse;\n\ninterface AccessLogInterface extends LoggerInterface\n{\n    public function logAccessForStaticResource(\n        Request $request,\n        StaticResourceResponse $response\n    ) : void;\n\n    public function logAccessForPsr7Resource(\n        Request $request,\n        ResponseInterface $response\n    ) : void;\n}\n\n\n\nTo allow usage of a standard PSR-3 logger, we also provide a decorator,\n\nZend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator\n, which decorates the PSR-3\nlogger and provides a standard implementation for the two methods listed above.\nIf you have defined a PSR-3 \nLoggerInterface\n service in your application, it\nwill be used automatically.\n\n\nFormatting logs\n\n\nThe Apache web server has long provided flexible and robust logging\ncapabilities, and its formats are used across a variety of web servers and\nlogging platforms. As such, we have chosen to use its formats for our standard\nimplementation. However, we allow you to plug in your own system as needed.\n\n\nYou can refer to the \nApache mod_log_config documentation\n\nin order to understand the available placeholders available for format strings.\n\n\nFormatting is provided to the \nPsr3AccessLogDecorator\n via instances of the\ninterface \nZend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface\n:\n\n\ninterface AccessLogFormatterInterface\n{\n    public function format(AccessLogDataMap $map) : string;\n}\n\n\n\nAccessLogDataMap\n is a class used internally by the \nPsr3AccessLogDecorator\n in\norder to map Apache log placeholders to request/response values.\n\n\nOur default \nAccessLogFormatterInterface\n implementation, \nAccessLogFormatter\n,\nprovides constants referencing the most common formats, but also allows you to\nuse arbitrary log formats that use the standard Apache placeholders. The formats\nwe include by default are:\n\n\n\n\nAccessLogFormatter::FORMAT_COMMON\n: Apache common log format: \n%h %l %u %t \"%r\" %>s %b\n\n\nAccessLogFormatter::FORMAT_COMMON_VHOST\n: Apache common log format + vhost: \n%v %h %l %u %t \"%r\" %>s %b\n\n\nAccessLogFormatter::FORMAT_COMBINED\n: Apache combined log format: \n%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"\n\n\nAccessLogFormatter::FORMAT_REFERER\n: \n%{Referer}i -> %U\n\n\nAccessLogFormatter::FORMAT_AGENT\n: \n%{User-Agent}i\n\n\nAccessLogFormatter::FORMAT_VHOST\n: Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b';\n\n\nAccessLogFormatter::FORMAT_COMMON_DEBIAN\n: Debian variant of common log format: \n%h %l %u %t \u201c%r\u201d %>s %O\n;\n\n\nAccessLogFormatter::FORMAT_COMBINED_DEBIAN\n: Debian variant of combined log format: \n%h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d\n;\n\n\nAccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN\n: Debian variant of combined log format + vhost: \n%v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\"\n;\n\n\n\n\nConfiguring a logger\n\n\nYou may subsitute your own logger implementation into the Swoole request handler\nrunner.\n\n\nManual usage\n\n\nIf you are manually instantiating a \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n\ninstance, you may provide it as the seventh argument to the constructor:\n\n\nuse Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner;\n\n$runner = new SwooleRequestHandlerRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $pidManager,\n    $serverFactory,\n    $staticResourceHandler,\n    $logger // <-- AccessLoggerInterface instance\n);\n\n\n\nContainer usage\n\n\nIf you are using a \nPSR-11\n container, the\n\nSwooleRequestHandlerRunnerFactory\n will retrieve a log instance using the\n\nZend\\Expressive\\Swoole\\Log\\AccessLogInterface\n service.\n\n\nYou have two options for substituting your own logger from there.\n\n\nFirst, you can create your own factory that produces an \nAccessLogInterface\n\ninstance, and map it to the service. This is the best route if you want to write\nyour own implementation, or want to use a different PSR-3 logger service.\n\n\nIf you are okay with re-using your existing PSR-3 logger, the provided\n\nZend\\Expressive\\Swoole\\Log\\AccessLogFactory\n will use the\n\nPsr\\Log\\LoggerInterface\n service to create a \nPsr3AccessLogDecorator\n instance.\n\n\nThis factory also allows you to specify a custom \nAccessLogFormatterInterface\n\ninstance if you want. It will look up a service by the fully-qualified interface\nname, and use it if present. Otherwise, it creates an \nAccessLogFormatter\n\ninstance for you.\n\n\nThe factory will also look at the following configuration values:\n\n\n'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'format' => string, // one of the AccessLogFormatter::FORMAT_*\n                                // constants, or a custom format string\n            'use-hostname-lookups' => bool, // Set to true to enable hostname lookups\n        ],\n    ],\n],\n\n\n\nUsing Monolog as a PSR-3 logger\n\n\nWhen using \nMonolog\n with a \nStreamHandler\n,\nyou must supply a file or a stream resource descriptor. We recommend using one\nof the following:\n\n\n\n\n\n\nphp://stdout\n is a good choice, as this will generally write to the current\n  console.\n\n\n\n\n\n\nphp://stderr\n is also a good choice, as this will generally write to the\n  current console, and allows you to filter based on that output stream.\n\n\n\n\n\n\nWhen using \nDocker\n, generally one of either\n  \n/proc/1/fd/1\n or \n/proc/1/fd/2\n can be used, and are analogous to \nSTDOUT\n\n  and \nSTDERR\n, respectively.  We recommend using \nphp://stdout\n and\n  \nphp://stderr\n instead, as these will be mapped to the correct locations by\n  the language.\n\n\n\n\n\n\n\n\nErrorLogHandler\n\n\nIf you plan to write to \nSTDERR\n, you might consider instead using the\nMonolog \nErrorLogHandler\n, as this will use PHP's \nerror_log()\n mechanism to\nwrite to the configured PHP error log. You can then either introspect that\nlocation, or configure the \nerror_log\n \nphp.ini\n setting to point to\neither \n/dev/stderr\n or, if on Docker, \n/proc/1/fd/2\n.\n\n\n\n\nAdditionally, we recommend using the \nPsrLogMessageProcessor\n with any Monolog\nhandler to ensure that any templated parameters are expanded by the logger.\n\n\nAs an example, the following is a factory that wires a \nStreamHandler\n to a\n\nMonolog\\Logger\n instance. \n\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\nuse Monolog\\Processor\\PsrLogMessageProcessor;\n\nclass LoggerFactory\n{\n    public function __invoke(ContainerInterface $container) : LoggerInterface\n    {\n        $logger = new Logger('swoole-http-server');\n        $logger->pushHandler(new StreamHandler(\n            'php://stdout',\n            Logger::INFO,\n            $bubble = true,\n            $expandNewLines = true\n        ));\n        $logger->pushProcessor(new PsrLogMessageProcessor());\n        return $logger;\n    }\n}\n\n\n\nIf you then wire this to the \nPsr\\Log\\LoggerInterface\n service, it will be used\nby Swoole for the purposes of access logs as well.",
            "title": "Logging"
        },
        {
            "location": "/v1/logging/#logging",
            "text": "Web servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.  Out-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.  We log a number of items:   When the web server starts, indicating the host and port on which it is running.  When workers start, including the working directory and worker ID.  When the web server stops.  When the web server reloads workers.  Each request (more on this below)   By default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any  PSR-3 compliant logger  to\nlog application details. We emit logs detailing server operations using the\npriority  Psr\\Log\\LogLevel::NOTICE  (unless detailing an error, such as\ninability to reload)), while  Psr\\Log\\LogLevel::INFO  and  Psr\\Log\\LogLevel::ERROR \nare used to log requests (errors are used for response statuses greater than or\nequal to 400).",
            "title": "Logging"
        },
        {
            "location": "/v1/logging/#access-logs",
            "text": "Technically, the  SwooleRequestHandlerRunner  doesn't use PSR-3 loggers\ndirectly, but, rather, instances of  Zend\\Expressive\\Swoole\\Log\\AccessLogInterface .\nThis package-specific interface extends the PSR-3 interface to add two methods:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Request;\nuse Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse;\n\ninterface AccessLogInterface extends LoggerInterface\n{\n    public function logAccessForStaticResource(\n        Request $request,\n        StaticResourceResponse $response\n    ) : void;\n\n    public function logAccessForPsr7Resource(\n        Request $request,\n        ResponseInterface $response\n    ) : void;\n}  To allow usage of a standard PSR-3 logger, we also provide a decorator, Zend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3\nlogger and provides a standard implementation for the two methods listed above.\nIf you have defined a PSR-3  LoggerInterface  service in your application, it\nwill be used automatically.",
            "title": "Access Logs"
        },
        {
            "location": "/v1/logging/#formatting-logs",
            "text": "The Apache web server has long provided flexible and robust logging\ncapabilities, and its formats are used across a variety of web servers and\nlogging platforms. As such, we have chosen to use its formats for our standard\nimplementation. However, we allow you to plug in your own system as needed.  You can refer to the  Apache mod_log_config documentation \nin order to understand the available placeholders available for format strings.  Formatting is provided to the  Psr3AccessLogDecorator  via instances of the\ninterface  Zend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface :  interface AccessLogFormatterInterface\n{\n    public function format(AccessLogDataMap $map) : string;\n}  AccessLogDataMap  is a class used internally by the  Psr3AccessLogDecorator  in\norder to map Apache log placeholders to request/response values.  Our default  AccessLogFormatterInterface  implementation,  AccessLogFormatter ,\nprovides constants referencing the most common formats, but also allows you to\nuse arbitrary log formats that use the standard Apache placeholders. The formats\nwe include by default are:   AccessLogFormatter::FORMAT_COMMON : Apache common log format:  %h %l %u %t \"%r\" %>s %b  AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost:  %v %h %l %u %t \"%r\" %>s %b  AccessLogFormatter::FORMAT_COMBINED : Apache combined log format:  %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"  AccessLogFormatter::FORMAT_REFERER :  %{Referer}i -> %U  AccessLogFormatter::FORMAT_AGENT :  %{User-Agent}i  AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b';  AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format:  %h %l %u %t \u201c%r\u201d %>s %O ;  AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format:  %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d ;  AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost:  %v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\" ;",
            "title": "Formatting logs"
        },
        {
            "location": "/v1/logging/#configuring-a-logger",
            "text": "You may subsitute your own logger implementation into the Swoole request handler\nrunner.",
            "title": "Configuring a logger"
        },
        {
            "location": "/v1/logging/#manual-usage",
            "text": "If you are manually instantiating a  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner \ninstance, you may provide it as the seventh argument to the constructor:  use Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner;\n\n$runner = new SwooleRequestHandlerRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $pidManager,\n    $serverFactory,\n    $staticResourceHandler,\n    $logger // <-- AccessLoggerInterface instance\n);",
            "title": "Manual usage"
        },
        {
            "location": "/v1/logging/#container-usage",
            "text": "If you are using a  PSR-11  container, the SwooleRequestHandlerRunnerFactory  will retrieve a log instance using the Zend\\Expressive\\Swoole\\Log\\AccessLogInterface  service.  You have two options for substituting your own logger from there.  First, you can create your own factory that produces an  AccessLogInterface \ninstance, and map it to the service. This is the best route if you want to write\nyour own implementation, or want to use a different PSR-3 logger service.  If you are okay with re-using your existing PSR-3 logger, the provided Zend\\Expressive\\Swoole\\Log\\AccessLogFactory  will use the Psr\\Log\\LoggerInterface  service to create a  Psr3AccessLogDecorator  instance.  This factory also allows you to specify a custom  AccessLogFormatterInterface \ninstance if you want. It will look up a service by the fully-qualified interface\nname, and use it if present. Otherwise, it creates an  AccessLogFormatter \ninstance for you.  The factory will also look at the following configuration values:  'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'format' => string, // one of the AccessLogFormatter::FORMAT_*\n                                // constants, or a custom format string\n            'use-hostname-lookups' => bool, // Set to true to enable hostname lookups\n        ],\n    ],\n],",
            "title": "Container usage"
        },
        {
            "location": "/v1/logging/#using-monolog-as-a-psr-3-logger",
            "text": "When using  Monolog  with a  StreamHandler ,\nyou must supply a file or a stream resource descriptor. We recommend using one\nof the following:    php://stdout  is a good choice, as this will generally write to the current\n  console.    php://stderr  is also a good choice, as this will generally write to the\n  current console, and allows you to filter based on that output stream.    When using  Docker , generally one of either\n   /proc/1/fd/1  or  /proc/1/fd/2  can be used, and are analogous to  STDOUT \n  and  STDERR , respectively.  We recommend using  php://stdout  and\n   php://stderr  instead, as these will be mapped to the correct locations by\n  the language.",
            "title": "Using Monolog as a PSR-3 logger"
        },
        {
            "location": "/v1/logging/#errorloghandler",
            "text": "If you plan to write to  STDERR , you might consider instead using the\nMonolog  ErrorLogHandler , as this will use PHP's  error_log()  mechanism to\nwrite to the configured PHP error log. You can then either introspect that\nlocation, or configure the  error_log   php.ini  setting to point to\neither  /dev/stderr  or, if on Docker,  /proc/1/fd/2 .   Additionally, we recommend using the  PsrLogMessageProcessor  with any Monolog\nhandler to ensure that any templated parameters are expanded by the logger.  As an example, the following is a factory that wires a  StreamHandler  to a Monolog\\Logger  instance.   use Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\nuse Monolog\\Processor\\PsrLogMessageProcessor;\n\nclass LoggerFactory\n{\n    public function __invoke(ContainerInterface $container) : LoggerInterface\n    {\n        $logger = new Logger('swoole-http-server');\n        $logger->pushHandler(new StreamHandler(\n            'php://stdout',\n            Logger::INFO,\n            $bubble = true,\n            $expandNewLines = true\n        ));\n        $logger->pushProcessor(new PsrLogMessageProcessor());\n        return $logger;\n    }\n}  If you then wire this to the  Psr\\Log\\LoggerInterface  service, it will be used\nby Swoole for the purposes of access logs as well.",
            "title": "ErrorLogHandler"
        },
        {
            "location": "/v1/how-it-works/",
            "text": "How it works\n\n\nWhen you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface, \nwithout using a web server\n.\n\n\nThis sounds a bit strange in PHP, though it will be familiar to \nNode.js\n\ndevelopers; the execution model under Swoole is similar to that technology.\n\n\nThe HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the \non(string $name, callable $action)\n method.\n\n\nThe request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the \non('request')\n\nevent of \nSwoole\\Http\\Server\n. This runner is implemented in the\n\nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n class.\n\n\nThe basic implementation looks similar to the following:\n\n\npublic function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}\n\n\n\nThis package provides a bridge between \nSwoole\\Http\\Request\n (\n$request\n) and\n\nPSR-7\n requests (\n$psr7Request\n;\nspecifically as implemented by \nzend-diactoros\n)\nvia the class \nZend\\Expressive\\Swoole\\ServerRequestSwooleFactory\n.\n\n\nIt also provides a Swoole-specific emitter, \nZend\\Expressive\\Swoole\\SwooleEmitter\n,\nthat converts a PSR-7 response to a \nSwoole\\Http\\Response\n instance.\n\n\nWhen you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4 \nworker\n\n(or \nreactor\n) processes and 1 \nmaster\n process, for a total of 5 PHP processes.\n\n\n\n\nThe advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.\n\n\nPerformance\n\n\nThe ZF developers performed a benchmark running the default \nzend-expressive-skeleton\n\napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.\n\n\nThe results demonstrated that \nExpressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache\n.\n\n\nThis impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.\n\n\nUnder Swoole 4.1+, for even better performance, you can enable the option\n\nzend-expressive-swoole.swoole-http-server.options.enable_coroutine\n. When this\nis enabled, Swoole will run most I/O processes in coroutines. Doing so provides\napproximately \n10 times faster performance\n than without coroutines, meaning a\nSwoole-based application can be 40 to 50 times faster than running under nginx\nor Apache. Performance improves with the number of workers (which are restricted\nby the amount of memory); as such, performance can increase from these numbers.",
            "title": "How it works"
        },
        {
            "location": "/v1/how-it-works/#how-it-works",
            "text": "When you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface,  without using a web server .  This sounds a bit strange in PHP, though it will be familiar to  Node.js \ndevelopers; the execution model under Swoole is similar to that technology.  The HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the  on(string $name, callable $action)  method.  The request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the  on('request') \nevent of  Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner  class.  The basic implementation looks similar to the following:  public function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}  This package provides a bridge between  Swoole\\Http\\Request  ( $request ) and PSR-7  requests ( $psr7Request ;\nspecifically as implemented by  zend-diactoros )\nvia the class  Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory .  It also provides a Swoole-specific emitter,  Zend\\Expressive\\Swoole\\SwooleEmitter ,\nthat converts a PSR-7 response to a  Swoole\\Http\\Response  instance.  When you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4  worker \n(or  reactor ) processes and 1  master  process, for a total of 5 PHP processes.   The advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.",
            "title": "How it works"
        },
        {
            "location": "/v1/how-it-works/#performance",
            "text": "The ZF developers performed a benchmark running the default  zend-expressive-skeleton \napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.  The results demonstrated that  Expressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache .  This impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.  Under Swoole 4.1+, for even better performance, you can enable the option zend-expressive-swoole.swoole-http-server.options.enable_coroutine . When this\nis enabled, Swoole will run most I/O processes in coroutines. Doing so provides\napproximately  10 times faster performance  than without coroutines, meaning a\nSwoole-based application can be 40 to 50 times faster than running under nginx\nor Apache. Performance improves with the number of workers (which are restricted\nby the amount of memory); as such, performance can increase from these numbers.",
            "title": "Performance"
        },
        {
            "location": "/v1/considerations/",
            "text": "Considerations when using Swoole\n\n\nBecause Swoole uses an event loop, and because it is able to load your\napplication exactly once, you must take several precautions when using it to\nserve your application.\n\n\nLong-running processes\n\n\nWhen using the Swoole HTTP server, your application runs within an \nevent\nloop\n. One benefit of this is that you\ncan then \ndefer\n\nexecution of code until the next tick of the loop. This can be used to delay\nlong-running code from executing until after a response has been sent to the\nclient, which can obviate the need for tools such as message queues.\n\n\nThe problem, however, is that when a worker \ndoes\n begin to handle the deferred\nfunctionality, it will run as long as needed until the work is done. This then\nmeans that the worker is \nblocked\n from handling new requests until that work is\ndone.\n\n\nIf you have enough workers, or the number of such long-running processes if few\nand far-between, this may not be an issue for you. However, it is a commonly\ndocumented issue in other similar systems such as Node.js. \nThe solution in these\ncases is the same as for general PHP applications: add a message queue to your\nsystems infrastructure, and delegate such work to the message queue instead.\n\n\n\n\nPDO Coroutine Support\n\n\nPlease be aware that enabling coroutine support with \nSwoole\\Runtime::enableCoroutine()\n\nonly decorates MySql PDO connections with coroutines; other drivers (e.g.,\npdo_pgsql) remain blocking as of Swoole 4.1.2.  > For more details,\n\nvisit the related bug report on the Swoole issue tracker\n.\n\n\n\n\nSessions\n\n\nBecause Swoole runs as a PHP CLI application, it generally does not play well\nwith the PHP Session extension. However, there are alternatives.\n\n\nzend-expressive-session-cache\n\n\nzend-expressive-session-cache\n\nprovides a persistence adapter for \nzend-expressive-session\n\nthat uses a \nPSR-6 CacheItemPoolInterface implementation\n\nfor storing and retrieving sessions. This approach requires that you setup a\nbackend cache storage for your session data.\n\n\npsr7-sessions/storageless\n\n\nPSR7Session\n provides session\nmiddleware that uses \nJWT tokens\n within\nthe session cookie to transmit session data between the server and client.\nThis approach requires no central session storage, but does impose limits on the\namount of information you can store in a session.\n\n\nStateless services\n\n\nThe typical PHP model is that the engine is fired up, runs your code, and then\ntears down again, \nfor every single request\n. As such, PHP is said to have a\n\"shared nothing architecture\". This is a tremendous boon to developers, as they\ncan ignore things found in lower level languages, such as garbage cleanup,\nmemory management, and more.\n\n\nThis model also comes with a cost: every single request requires bootstrapping\nyour application. Benchmarks we have performed show that bootstrapping is often\nthe most expensive operation in applications, often accounting for 25-50% of\ntotal resource usage and execution time.\n\n\nOne reason technologies such as Swoole can provide a performance boost is due to\nthe fact that they can bootstrap your application exactly once, often during\nstartup. This alone can account for the performance boost of many applications.\n\n\nHowever, it has a price: you now need to consider what changes may happen inside\nthe various classes in your dependency injection container, and the impact those\nchanges may have on later requests, or even other requests happening\nconcurrently.\n\n\nAs one example: \nzend-expressive-template\n\nprovides an interface, \nTemplateRendererInterface\n, that allows you to render a\ntemplate. That interface also allows you to provide template paths, and default\nparameters to pass to every template, and these methods are often invoked within\nfactories or delegators in order to configure the renderer implementation.\nHowever, we have \nalso documented using \naddDefaultParam()\n for passing values\ndiscovered in the request to later handlers\n.\nThis practice accumulates \nstate\n in the renderer that can cause problems later:\n\n\n\n\n\n\nFlash messages discovered in one request might then be pushed to templates\n  renderered in subsequent requests \u2014 when they are no longer in scope. \n\n\n\n\n\n\nUser details from one request might persist to a template rendered for an\n  unauthenticated user in another request, exposing information.\n\n\n\n\n\n\nThese are clearly problematic behaviors!\n\n\nAs such, you must guard against state in services you provide in your dependency\ninjection container, as any state changes have ramifications for other requests.\nWrite services to be stateless, and/or mark state-changing methods as\n\n@internal\n to prevent users from calling them in non-bootstrap code.\n\n\nIf the services are provided by a third party, you have a few options:\n\n\n\n\n\n\nDecorating an existing service that implements an interface to make it\n  stateless.\n\n\n\n\n\n\nExtending a service to make state-changing methods no-ops.\n\n\n\n\n\n\nInjecting factories that produce the stateful services, instead of the service\n  itself.\n\n\n\n\n\n\nWe'll look at each in detail.\n\n\nDecoration\n\n\nIf a service implements an interface, you can decorate the service to make it\nstateless. Well-written interfaces will be stateless by design, and not provide\nmethods meant to internally change state. In these situations, you can create a\nproxy class that decorates the original service:\n\n\nclass ProxyService implements OriginalInterface\n{\n    /** @var OriginalInterface */\n    private $proxy;\n\n    public function __construct(OriginalInterface $proxy)\n    {\n        $this->proxy = $proxy;\n    }\n\n    public function someMethodDefinedInInterface(string $argument) : Result\n    {\n        return $this->proxy->someMethodDefinedInInterface($argument);\n    }\n}\n\n\n\nYou would then:\n\n\n\n\nMap the factory for the original service to the implementation name.\n\n\nCreate a factory that consumes the original service, and produces the proxy.\n\n\nMap the interface name to the factory that creates the proxy.\n\n\n\n\n// in config/autoload/dependencies.global.php:\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            OriginalImplementation::class => OriginalImplementationFactory::class,\n            OriginalInterface::class => ProxyServiceFactory::class,\n        ],\n    ],\n];\n\n\n\nIf you were writing to the interface, and not the implementation, you can now\nguarantee that any non-interface methods that changed state can now no longer be\ncalled.\n\n\nIf the interface itself defines methods that modify state, we recommend writing\na proxy that implements those methods as no-ops and/or that raises exceptions\nwhen those methods are invoked. (The latter approach ensures that you discover\nquickly when code is exercising those methods.) In each case, you would then use\na \ndelegator factory\n,\nto decorate the original instance in the proxy class:\n\n\nfunction (ContainerInterface $container, string $name, callable $callback)\n{\n    return new ProxyService($callback());\n}\n\n\n\n(You can also use the delegator factory approach with the previous proxy service\nexample.)\n\n\nExtension\n\n\nWhen a service does not implement an interface, but exposes methods that change\ninternal state, you can extend the original class to make the methods that\nchange state into no-ops, or have them raise exceptions. (The latter approach\nensures that you discover quickly when code is exercising those methods.)\n\n\nAs an example, let's say you have a class \nDataMapper\n that defines a method\n\nsetTable()\n in it, and that method would change the database table the mapper\nwould query. This is a potentially bad situation!\n\n\nWe could extend the class as follows:\n\n\nclass StatelessDataMapper extends DataMapper\n{\n    public function setTable(string $table) : void\n    {\n        throw new \\DomainException(sprintf(\n            '%s should not be called in production code!',\n            __METHOD__\n        ));\n    }\n}\n\n\n\nIn your factory that creates an instance of \nDataMapper\n, have it instead return\na \nStatelessDataMapper\n instance, and you're now safe.\n\n\nFactories\n\n\nAnother approach is to modify your consuming code to accept a \nfactory\n that\nwill produce the service you'll consume, instead of the service itself. This\napproach ensures that the service is created only when needed, mitigating any\nstate change issues.\n\n\nAs an example, consider the following middleware that currently consumes a\ntemplate renderer:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var TemplateRendererInterface */\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        return new HtmlResponse($this->renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}\n\n\n\nWhat we will do is modify it to accept a \ncallable\n to the constructor. We will\nthen call that factory \njust before\n we need the renderer; we \nwill not\n store\nthe result in the handler, as we want to ensure we have a new instance each\ntime.\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var callable */\n    private $rendererFactory;\n\n    public function __construct(callable $rendererFactory)\n    {\n        $this->rendererFactory = $rendererFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        /** @var TemplateRendererInterface $renderer */\n        $renderer = ($this->rendererFactory)();\n        return new HtmlResponse($renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}\n\n\n\nFrom here, we create a factory for our dependency injection container that will\nreturn the factory we use here. As an example, if we are using the \nzend-view\nintegration\n,\nwe might do the following:\n\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Expressive\\ZendView\\ZendViewRendererFactory;\n\nclass ZendViewRendererFactoryFactory\n{\n    public function __invoke(ContainerInterface $container) : callable\n    {\n        $factory = new ZendViewRendererFactory();\n        return function () use ($container, $factory) : TemplateRendererInterface {\n            return $factory($container);\n        };\n    }\n}\n\n\n\nIf we mapped this to the \"service\" \nZend\\Expressive\\Template\\TemplateRendererInterfaceFactory\n,\nour factory for the \nSomeHandler\n class would then look like:\n\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory;\n\nfunction (ContainerInterface $container) : SomeHandler\n{\n    return new SomeHandler(\n        $container->get(TemplateRendererInterfaceFactory::class)\n    );\n}\n\n\n\nThis approach ensures we get a new instance with known state at precisely the\nmoment we wish to execute the functionality. By ensuring we \ndo not\n store the\ninstance in any way, we also ensure it is garbage collected when the instance\ngoes out of scope (i.e., when the method ends).\n\n\n\n\nHandling the template data problem\n\n\nIf we want our services to be stateless, how do we handle problems such as the \n\ndocumented \naddDefaultParam()\n issue referenced earlier\n?\n\n\nIn this case, the original problem was \"how do we get common request data into\ntemplates?\" The solution originally provided was to alter the state of the\ntemplate renderer. Another solution, however, is one we've also documented\npreviously: \nuse server attributes to pass data between middleware\n.\n\n\nIn this particular case, the middleware documented in the original solution\ncould be modified to provide data to a request attribute, instead of altering\nthe state of the template renderer. It might then become:\n\n\nnamespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Session\\Authentication\\UserInterface;\nuse Zend\\Expressive\\Session\\Flash\\FlashMessagesInterface;\n\nclass TemplateDefaultsMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $routeResult = $request->getAttribute(RouteResult::class);\n        $flashMessages = $request->getAttribute(FlashMessagesInterface::class);\n\n        $defaults = [\n            // Inject the current user, or null if there isn't one.\n            // This is named security so it will not interfere with your user admin pages\n            'security' => $request->getAttribute(UserInterface::class),\n\n            // Inject the currently matched route name.\n            'matchedRouteName' => $routeResult ? $routeResult->getMatchedRouteName() : null,\n\n            // Inject all flash messages\n            'notifications' => $flashMessages ? $flashMessages->getFlashes() : [],\n        ];\n\n        return $handler->handle($request->withAttribute(__CLASS__, $defaults));\n    }\n}\n\n\n\nOnce that change is made, you would then change your handler to do the\nfollowing:\n\n\n\n\nPull that attribute, providing a default \n[]\n value.\n\n\nMerge the pulled value with any local values when rendering the template.\n\n\n\n\nFor example:\n\n\n$defaultParams = $request->getAttribute(TemplateDefaultsMiddleware::class, []);\nreturn new HtmlResponse($renderer->render(\n    'some::template',\n    array_merge($defaultParams, [\n        // handler-specific parameters here\n    ])\n));\n\n\n\nThis approach, while it requires more work on the part of handler authors,\nensures that the renderer state does not vary between requests, making it\nsafer for usage with Swoole and other long-running processes.",
            "title": "Considerations when using Swoole"
        },
        {
            "location": "/v1/considerations/#considerations-when-using-swoole",
            "text": "Because Swoole uses an event loop, and because it is able to load your\napplication exactly once, you must take several precautions when using it to\nserve your application.",
            "title": "Considerations when using Swoole"
        },
        {
            "location": "/v1/considerations/#long-running-processes",
            "text": "When using the Swoole HTTP server, your application runs within an  event\nloop . One benefit of this is that you\ncan then  defer \nexecution of code until the next tick of the loop. This can be used to delay\nlong-running code from executing until after a response has been sent to the\nclient, which can obviate the need for tools such as message queues.  The problem, however, is that when a worker  does  begin to handle the deferred\nfunctionality, it will run as long as needed until the work is done. This then\nmeans that the worker is  blocked  from handling new requests until that work is\ndone.  If you have enough workers, or the number of such long-running processes if few\nand far-between, this may not be an issue for you. However, it is a commonly\ndocumented issue in other similar systems such as Node.js.  The solution in these\ncases is the same as for general PHP applications: add a message queue to your\nsystems infrastructure, and delegate such work to the message queue instead.",
            "title": "Long-running processes"
        },
        {
            "location": "/v1/considerations/#pdo-coroutine-support",
            "text": "Please be aware that enabling coroutine support with  Swoole\\Runtime::enableCoroutine() \nonly decorates MySql PDO connections with coroutines; other drivers (e.g.,\npdo_pgsql) remain blocking as of Swoole 4.1.2.  > For more details, visit the related bug report on the Swoole issue tracker .",
            "title": "PDO Coroutine Support"
        },
        {
            "location": "/v1/considerations/#sessions",
            "text": "Because Swoole runs as a PHP CLI application, it generally does not play well\nwith the PHP Session extension. However, there are alternatives.",
            "title": "Sessions"
        },
        {
            "location": "/v1/considerations/#zend-expressive-session-cache",
            "text": "zend-expressive-session-cache \nprovides a persistence adapter for  zend-expressive-session \nthat uses a  PSR-6 CacheItemPoolInterface implementation \nfor storing and retrieving sessions. This approach requires that you setup a\nbackend cache storage for your session data.",
            "title": "zend-expressive-session-cache"
        },
        {
            "location": "/v1/considerations/#psr7-sessionsstorageless",
            "text": "PSR7Session  provides session\nmiddleware that uses  JWT tokens  within\nthe session cookie to transmit session data between the server and client.\nThis approach requires no central session storage, but does impose limits on the\namount of information you can store in a session.",
            "title": "psr7-sessions/storageless"
        },
        {
            "location": "/v1/considerations/#stateless-services",
            "text": "The typical PHP model is that the engine is fired up, runs your code, and then\ntears down again,  for every single request . As such, PHP is said to have a\n\"shared nothing architecture\". This is a tremendous boon to developers, as they\ncan ignore things found in lower level languages, such as garbage cleanup,\nmemory management, and more.  This model also comes with a cost: every single request requires bootstrapping\nyour application. Benchmarks we have performed show that bootstrapping is often\nthe most expensive operation in applications, often accounting for 25-50% of\ntotal resource usage and execution time.  One reason technologies such as Swoole can provide a performance boost is due to\nthe fact that they can bootstrap your application exactly once, often during\nstartup. This alone can account for the performance boost of many applications.  However, it has a price: you now need to consider what changes may happen inside\nthe various classes in your dependency injection container, and the impact those\nchanges may have on later requests, or even other requests happening\nconcurrently.  As one example:  zend-expressive-template \nprovides an interface,  TemplateRendererInterface , that allows you to render a\ntemplate. That interface also allows you to provide template paths, and default\nparameters to pass to every template, and these methods are often invoked within\nfactories or delegators in order to configure the renderer implementation.\nHowever, we have  also documented using  addDefaultParam()  for passing values\ndiscovered in the request to later handlers .\nThis practice accumulates  state  in the renderer that can cause problems later:    Flash messages discovered in one request might then be pushed to templates\n  renderered in subsequent requests \u2014 when they are no longer in scope.     User details from one request might persist to a template rendered for an\n  unauthenticated user in another request, exposing information.    These are clearly problematic behaviors!  As such, you must guard against state in services you provide in your dependency\ninjection container, as any state changes have ramifications for other requests.\nWrite services to be stateless, and/or mark state-changing methods as @internal  to prevent users from calling them in non-bootstrap code.  If the services are provided by a third party, you have a few options:    Decorating an existing service that implements an interface to make it\n  stateless.    Extending a service to make state-changing methods no-ops.    Injecting factories that produce the stateful services, instead of the service\n  itself.    We'll look at each in detail.",
            "title": "Stateless services"
        },
        {
            "location": "/v1/considerations/#decoration",
            "text": "If a service implements an interface, you can decorate the service to make it\nstateless. Well-written interfaces will be stateless by design, and not provide\nmethods meant to internally change state. In these situations, you can create a\nproxy class that decorates the original service:  class ProxyService implements OriginalInterface\n{\n    /** @var OriginalInterface */\n    private $proxy;\n\n    public function __construct(OriginalInterface $proxy)\n    {\n        $this->proxy = $proxy;\n    }\n\n    public function someMethodDefinedInInterface(string $argument) : Result\n    {\n        return $this->proxy->someMethodDefinedInInterface($argument);\n    }\n}  You would then:   Map the factory for the original service to the implementation name.  Create a factory that consumes the original service, and produces the proxy.  Map the interface name to the factory that creates the proxy.   // in config/autoload/dependencies.global.php:\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            OriginalImplementation::class => OriginalImplementationFactory::class,\n            OriginalInterface::class => ProxyServiceFactory::class,\n        ],\n    ],\n];  If you were writing to the interface, and not the implementation, you can now\nguarantee that any non-interface methods that changed state can now no longer be\ncalled.  If the interface itself defines methods that modify state, we recommend writing\na proxy that implements those methods as no-ops and/or that raises exceptions\nwhen those methods are invoked. (The latter approach ensures that you discover\nquickly when code is exercising those methods.) In each case, you would then use\na  delegator factory ,\nto decorate the original instance in the proxy class:  function (ContainerInterface $container, string $name, callable $callback)\n{\n    return new ProxyService($callback());\n}  (You can also use the delegator factory approach with the previous proxy service\nexample.)",
            "title": "Decoration"
        },
        {
            "location": "/v1/considerations/#extension",
            "text": "When a service does not implement an interface, but exposes methods that change\ninternal state, you can extend the original class to make the methods that\nchange state into no-ops, or have them raise exceptions. (The latter approach\nensures that you discover quickly when code is exercising those methods.)  As an example, let's say you have a class  DataMapper  that defines a method setTable()  in it, and that method would change the database table the mapper\nwould query. This is a potentially bad situation!  We could extend the class as follows:  class StatelessDataMapper extends DataMapper\n{\n    public function setTable(string $table) : void\n    {\n        throw new \\DomainException(sprintf(\n            '%s should not be called in production code!',\n            __METHOD__\n        ));\n    }\n}  In your factory that creates an instance of  DataMapper , have it instead return\na  StatelessDataMapper  instance, and you're now safe.",
            "title": "Extension"
        },
        {
            "location": "/v1/considerations/#factories",
            "text": "Another approach is to modify your consuming code to accept a  factory  that\nwill produce the service you'll consume, instead of the service itself. This\napproach ensures that the service is created only when needed, mitigating any\nstate change issues.  As an example, consider the following middleware that currently consumes a\ntemplate renderer:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var TemplateRendererInterface */\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        return new HtmlResponse($this->renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}  What we will do is modify it to accept a  callable  to the constructor. We will\nthen call that factory  just before  we need the renderer; we  will not  store\nthe result in the handler, as we want to ensure we have a new instance each\ntime.  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var callable */\n    private $rendererFactory;\n\n    public function __construct(callable $rendererFactory)\n    {\n        $this->rendererFactory = $rendererFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        /** @var TemplateRendererInterface $renderer */\n        $renderer = ($this->rendererFactory)();\n        return new HtmlResponse($renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}  From here, we create a factory for our dependency injection container that will\nreturn the factory we use here. As an example, if we are using the  zend-view\nintegration ,\nwe might do the following:  \nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Expressive\\ZendView\\ZendViewRendererFactory;\n\nclass ZendViewRendererFactoryFactory\n{\n    public function __invoke(ContainerInterface $container) : callable\n    {\n        $factory = new ZendViewRendererFactory();\n        return function () use ($container, $factory) : TemplateRendererInterface {\n            return $factory($container);\n        };\n    }\n}  If we mapped this to the \"service\"  Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory ,\nour factory for the  SomeHandler  class would then look like:  use Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory;\n\nfunction (ContainerInterface $container) : SomeHandler\n{\n    return new SomeHandler(\n        $container->get(TemplateRendererInterfaceFactory::class)\n    );\n}  This approach ensures we get a new instance with known state at precisely the\nmoment we wish to execute the functionality. By ensuring we  do not  store the\ninstance in any way, we also ensure it is garbage collected when the instance\ngoes out of scope (i.e., when the method ends).",
            "title": "Factories"
        },
        {
            "location": "/v1/considerations/#handling-the-template-data-problem",
            "text": "If we want our services to be stateless, how do we handle problems such as the  documented  addDefaultParam()  issue referenced earlier ?  In this case, the original problem was \"how do we get common request data into\ntemplates?\" The solution originally provided was to alter the state of the\ntemplate renderer. Another solution, however, is one we've also documented\npreviously:  use server attributes to pass data between middleware .  In this particular case, the middleware documented in the original solution\ncould be modified to provide data to a request attribute, instead of altering\nthe state of the template renderer. It might then become:  namespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Session\\Authentication\\UserInterface;\nuse Zend\\Expressive\\Session\\Flash\\FlashMessagesInterface;\n\nclass TemplateDefaultsMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $routeResult = $request->getAttribute(RouteResult::class);\n        $flashMessages = $request->getAttribute(FlashMessagesInterface::class);\n\n        $defaults = [\n            // Inject the current user, or null if there isn't one.\n            // This is named security so it will not interfere with your user admin pages\n            'security' => $request->getAttribute(UserInterface::class),\n\n            // Inject the currently matched route name.\n            'matchedRouteName' => $routeResult ? $routeResult->getMatchedRouteName() : null,\n\n            // Inject all flash messages\n            'notifications' => $flashMessages ? $flashMessages->getFlashes() : [],\n        ];\n\n        return $handler->handle($request->withAttribute(__CLASS__, $defaults));\n    }\n}  Once that change is made, you would then change your handler to do the\nfollowing:   Pull that attribute, providing a default  []  value.  Merge the pulled value with any local values when rendering the template.   For example:  $defaultParams = $request->getAttribute(TemplateDefaultsMiddleware::class, []);\nreturn new HtmlResponse($renderer->render(\n    'some::template',\n    array_merge($defaultParams, [\n        // handler-specific parameters here\n    ])\n));  This approach, while it requires more work on the part of handler authors,\nensures that the renderer state does not vary between requests, making it\nsafer for usage with Swoole and other long-running processes.",
            "title": "Handling the template data problem"
        },
        {
            "location": "/intro/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-swoole/v1/intro/';\n  });",
            "title": "_introduction"
        },
        {
            "location": "/static-resources/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-swoole/v1/static-resources/';\n  });",
            "title": "_static-resources"
        },
        {
            "location": "/logging/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-swoole/v1/logging/';\n  });",
            "title": "_logging"
        },
        {
            "location": "/how_it_works/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-swoole/v1/how-it-works/';\n  });",
            "title": "_how-it-works"
        }
    ]
}