{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-swoole\n\n\n\n\n\n\nThis library provides the support of \nSwoole\n into\nan \nExpressive\n application. This means you can\nexecute your Expressive application using Swoole directly from the command line.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nConfiguration\n\n\nAfter installing zend-expressive-swoole, you will need to first enable the\ncomponent, and then optionally configure it.\n\n\nWe recommend adding a new configuration file to your autoload directory,\n\nconfig/autoload/swoole.local.php\n. To begin with, use the following contents:\n\n\n<?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), []);\n\n\n\nThe above will setup the Swoole integration for your application.\n\n\nBy default, Swoole executes the HTTP server with host \n127.0.0.1\n on port\n\n8080\n. You can change these values via configuration. Assuming you have the\nabove, modify it to read as follows:\n\n\n<?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => 'insert hostname to use here',\n            'port' => 80, // use an integer value here\n        ],\n    ],\n]);\n\n\n\n\n\nExpressive skeleton 3.1.0 and later\n\n\nIf you have built your application on the 3.1.0 or later version of the\nExpressive skeleton, you do not need to instantiate and invoke the package's\n\nConfigProvider\n, as the skeleton supports it out of the box.\n\n\nYou will only need to provide any additional configuration of the HTTP server.\n\n\n\n\nExecute\n\n\nOnce you have performed the configuration steps as outlined above, you can run\nan Expressive application with Swoole using the following command:\n\n\nphp public/index.php start\n\n\n\nDocumentation\n\n\nBrowse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/\n\n\nSupport\n\n\n\n\nIssues\n\n\nChat\n\n\nForum",
            "title": "Home"
        },
        {
            "location": "/#zend-expressive-swoole",
            "text": "This library provides the support of  Swoole  into\nan  Expressive  application. This means you can\nexecute your Expressive application using Swoole directly from the command line.",
            "title": "zend-expressive-swoole"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-swoole",
            "title": "Installation"
        },
        {
            "location": "/#configuration",
            "text": "After installing zend-expressive-swoole, you will need to first enable the\ncomponent, and then optionally configure it.  We recommend adding a new configuration file to your autoload directory, config/autoload/swoole.local.php . To begin with, use the following contents:  <?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), []);  The above will setup the Swoole integration for your application.  By default, Swoole executes the HTTP server with host  127.0.0.1  on port 8080 . You can change these values via configuration. Assuming you have the\nabove, modify it to read as follows:  <?php\n\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn array_merge((new ConfigProvider())(), [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => 'insert hostname to use here',\n            'port' => 80, // use an integer value here\n        ],\n    ],\n]);",
            "title": "Configuration"
        },
        {
            "location": "/#expressive-skeleton-310-and-later",
            "text": "If you have built your application on the 3.1.0 or later version of the\nExpressive skeleton, you do not need to instantiate and invoke the package's ConfigProvider , as the skeleton supports it out of the box.  You will only need to provide any additional configuration of the HTTP server.",
            "title": "Expressive skeleton 3.1.0 and later"
        },
        {
            "location": "/#execute",
            "text": "Once you have performed the configuration steps as outlined above, you can run\nan Expressive application with Swoole using the following command:  php public/index.php start",
            "title": "Execute"
        },
        {
            "location": "/#documentation",
            "text": "Browse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/",
            "title": "Documentation"
        },
        {
            "location": "/#support",
            "text": "Issues  Chat  Forum",
            "title": "Support"
        },
        {
            "location": "/v1/intro/",
            "text": "Swoole\n\n\nSwoole\n is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.\n\n\nInstall swoole\n\n\nYou can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:\n\n\n$ pecl install swoole\n\n\n\nFor more information on the extension, \nvisit its package details on PECL\n.\n\n\nInstall zend-expressive-swoole\n\n\nTo install this package, use \nComposer\n:\n\n\n$ composer require zendframework/zend-expressive-swoole\n\n\n\nSwoole with Expressive\n\n\nzend-expressive-swoole enables an Expressive application to be executed with\nthe \nSwoole\n extension. This means you can run the\napplication from the command line, \nwithout requiring a web server\n.\n\n\nYou can run the application using the following command:\n\n\n$ php public/index.php\n\n\n\nThis command will execute Swoole on \nlocalhost\n via port \n8080\n.\n\n\n\n\nExpressive skeleton versions prior to 3.1.0\n\n\nThe above will work immediately after installing zend-expressive-swoole if you\nare using a version of \nzend-expressive-skeleton\n\nfrom 3.1.0 or later.\n\n\nFor applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as \nconfig/autoload/zend-expressive-swoole.global.php\n\nor \nconfig/autoload/zend-expressive-swoole.local.php\n with the following\ncontents:\n\n\n<?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();\n\n\n\n\n\nYou can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:\n\n\n// In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];\n\n\n\nProviding additional Swoole configuration\n\n\nYou can also configure the Swoole HTTP server using an \noptions\n key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:\n\n\n// config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS;\n                                   // SWOOLE_BASE is the default\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server\n            'options' => [\n                // Set the SSL certificate and key paths for SSL support:\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n                // Available in Swoole 4.1 and up; enables coroutine support\n                // for most I/O operations:\n                'enable_coroutine' => true,\n            ],\n        ],\n    ],\n];\n\n\n\nServing static files\n\n\nWe support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant \nZend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\nOur static resource capabilities are fairly comprehensive; please see the\n\nchapter on static resources\n for full details on\nconfiguration.",
            "title": "Introduction"
        },
        {
            "location": "/v1/intro/#swoole",
            "text": "Swoole  is a PECL extension for developing\nasynchronous applications in PHP. It enables PHP developers to write\nhigh-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket\nservices without requiring in-depth knowledge about non-blocking I/O programming\nor the low-level Linux kernel.",
            "title": "Swoole"
        },
        {
            "location": "/v1/intro/#install-swoole",
            "text": "You can install the Swoole extension on Linux or Mac environments using the\nfollowing commands:  $ pecl install swoole  For more information on the extension,  visit its package details on PECL .",
            "title": "Install swoole"
        },
        {
            "location": "/v1/intro/#install-zend-expressive-swoole",
            "text": "To install this package, use  Composer :  $ composer require zendframework/zend-expressive-swoole",
            "title": "Install zend-expressive-swoole"
        },
        {
            "location": "/v1/intro/#swoole-with-expressive",
            "text": "zend-expressive-swoole enables an Expressive application to be executed with\nthe  Swoole  extension. This means you can run the\napplication from the command line,  without requiring a web server .  You can run the application using the following command:  $ php public/index.php  This command will execute Swoole on  localhost  via port  8080 .",
            "title": "Swoole with Expressive"
        },
        {
            "location": "/v1/intro/#expressive-skeleton-versions-prior-to-310",
            "text": "The above will work immediately after installing zend-expressive-swoole if you\nare using a version of  zend-expressive-skeleton \nfrom 3.1.0 or later.  For applications based on previous versions of the skeleton, you will need to\ncreate a configuration file such as  config/autoload/zend-expressive-swoole.global.php \nor  config/autoload/zend-expressive-swoole.local.php  with the following\ncontents:  <?php\nuse Zend\\Expressive\\Swoole\\ConfigProvider;\n\nreturn (new ConfigProvider())();   You can change the host address and/or host name as well as the port using a\nconfiguration file, as follows:  // In config/autoload/swoole.local.php:\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n        ],\n    ],\n];",
            "title": "Expressive skeleton versions prior to 3.1.0"
        },
        {
            "location": "/v1/intro/#providing-additional-swoole-configuration",
            "text": "You can also configure the Swoole HTTP server using an  options  key to specify\nany accepted Swoole settings. For instance, the following configuration\ndemonstrates enabling SSL:  // config/autoload/swoole.local.php\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'host' => '192.168.0.1',\n            'port' => 9501,\n            'mode' => SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS;\n                                   // SWOOLE_BASE is the default\n            'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server\n            'options' => [\n                // Set the SSL certificate and key paths for SSL support:\n                'ssl_cert_file' => 'path/to/ssl.crt',\n                'ssl_key_file' => 'path/to/ssl.key',\n                // Available in Swoole 4.1 and up; enables coroutine support\n                // for most I/O operations:\n                'enable_coroutine' => true,\n            ],\n        ],\n    ],\n];",
            "title": "Providing additional Swoole configuration"
        },
        {
            "location": "/v1/intro/#serving-static-files",
            "text": "We support serving static files. By default, we serve files with extensions in\nthe whitelist defined in the constant  Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .\nOur static resource capabilities are fairly comprehensive; please see the chapter on static resources  for full details on\nconfiguration.",
            "title": "Serving static files"
        },
        {
            "location": "/v1/static-resources/",
            "text": "Static Resources\n\n\nOne feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.\n\n\nTo enable this, the package provides an alternate\n\nRequestHandlerRunner\n\nimplementation via the class \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n\nthat performs two duties:\n\n\n\n\nIf a static resource is matched, it serves that.\n\n\nOtherwise, it passes off handling to the composed application pipeline.\n\n\n\n\nInternally, the \nSwooleRequestHandlerRunner\n composes another class, a \n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n instance. This instance\nis passed the Swoole request and response, and returns a value indicating\nwhether or not it was able to identify and serve a matching static resource.\n\n\nOur default implementation, \nZend\\Expressive\\Swoole\\StaticResourceHandler\n,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.\n\n\nMiddleware\n\n\nThe \nStaticResourceHandler\n implementation performs its work by composing a\nqueue of middleware to execute when attempting to serve a matched file. Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:\n\n\n\n\n\n\nCacheControlMiddleware\n will set a \nCache-Control\n header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the \nCache-Control\n directive to\n  use when the match occurs.\n\n\n\n\n\n\nClearStatCacheMiddleware\n will, if configured to do so, call\n  \nclearstatcache()\n either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.\n\n\n\n\n\n\nContentTypeFilterMiddleware\n checks the incoming filename against a map of\n  known extensions and their associated Content-Type values. If it cannot\n  match the file, it returns a value indicating no match was found so that the\n  application can continue processing the request. Otherwise, it provides the\n  Content-Type for the associated response. This middleware is generally best\n  used as the outermost layer, to ensure no other middleware executes in the\n  case that the file cannot be matched.\n\n\n\n\n\n\nETagMiddleware\n will set an \nETag\n header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the \nETag\n\n  header value matches either an \nIf-Match\n or \nIf-None-Match\n request header,\n  it will provide a response status of \n304\n and disable sending content.\n\n\n\n\n\n\nGzipMiddleware\n detects the \nAccept-Encoding\n request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.\n\n\n\n\n\n\nHeadMiddleware\n will force an empty response. (The status and headers may be\n  set by other middleware.)\n\n\n\n\n\n\nLastModifiedMiddleware\n will set a \nLast-Modified\n header using the\n  \nfilemtime()\n value of the requested resource. If the header value is later\n  than an \nIf-Modified-Since\n  request header, it will provide a response status\n  of \n304\n and disable sending content.\n\n\n\n\n\n\nMethodNotAllowedMiddleware\n will set the response status to \n405\n, and set an\n  \nAllow\n header indicating the allowed methods when an unsupported request\n  method is provided.\n\n\n\n\n\n\nOptionsMiddleware\n will force an empty response with an \nAllow\n header set\n  to the allowed methods. (Other headers may also be present!)\n\n\n\n\n\n\nBy default, these are registered in the following order, contingent on\nconfiguration being provided:\n\n\n\n\nContentTypeFilterMiddleware\n\n\nMethodNotAllowedMiddleware\n\n\nOptionsMiddleware\n\n\nHeadMiddleware\n\n\nGzipMiddleware\n\n\nClearStatCacheMiddleware\n\n\nCacheControlMiddleware\n\n\nLastModifiedMiddleware\n\n\nETagMiddleware\n\n\n\n\nThis approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the \nLast-Modified\n or \nETag\n headers); it also\nensures that all possible headers are provided whenever possible (e.g., a \nHEAD\n\nrequest should also expose \nCache-Control\n, \nLast-Modified\n, and \nETag\n\nheaders).\n\n\n\n\nProviding your own middleware\n\n\nIf you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate\n\nStaticResourceHandler\n factory. In most cases, you can extend\n\nStaticResourceHandlerFactory\n and override the \nconfigureMiddleware(array\n$config) : array\n method to do so. Be sure to remember to add a \ndependencies\n\nsetting mapping the \nStaticResourceHandlerInterface\n service to your new factory\nwhen done!\n\n\n\n\nConfiguration\n\n\nWe provide a factory for the \nStaticResourceHandler\n that uses a\nconfiguration-driven approach in order to:\n\n\n\n\nSet the document root.\n\n\nSet the map of allowed extensions to content-types.\n\n\nConfigure and provide middleware.\n\n\n\n\nThe following demonstrates all currently available configuration options:\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nSecurity warning\n\n\nNever add \nphp\n as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!\n\n\nDocument root\n\n\nIf no \ndocument_root\n configuration is present, the default is to use\n\ngetcwd() . '/public'\n. If either the configured or default document root\ndoes not exist, we raise an exception.\n\n\nDefault extension/content-types\n\n\nBy default, we serve files with extensions in the whitelist defined in the\nconstant \nZend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS\n,\nwhich is derived from a \nlist of common web MIME types maintained by Mozilla\n.\n\n\n\n\nConfiguration Example\n\n\nThe example which follows provides the following options:\n\n\n\n\nSets the document root to \n/var/www/htdocs\n.\n\n\nAdds a custom extension / content-type map.\n\n\nProvides a clearstatcache interval of 2 hours.\n\n\nSelects the \"strong\" ETag algorithm.\n\n\nIndicates a gzip compression level of 3.\n\n\nSets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.\n\n\nSets Cache-Control directives for plain text files.\n\n\n\n\n// config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nWriting Middleware\n\n\nStatic resource middleware must implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface\n, which\ndefines the following:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}\n\n\n\nThe \n$next\n argument has the following signature:\n\n\nnamespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;\n\n\n\nTypically, middleware will look something like this:\n\n\n$response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.\n\n\n\nMiddleware either produces or manipulates a\n\nZend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse\n instance.\nThat class looks like the following:\n\n\nclass StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * Call this method to indicate that the request cannot be served as a\n     * static resource. The request runner will then proceed to execute\n     * the associated application in order to generate the response.\n     */\n    public function markAsFailure() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    /**\n     * Use this within a response content callback to set the associated\n     * Content-Length of the generated response. Loggers can then query\n     * for this information in order to provide that information in the logs.\n     */\n    public function setContentLength(int $length) : void;\n\n    public function setStatus(int $status) : void;\n}\n\n\n\nMost middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via \ndisableContent()\n).\nMiddleware that restricts access or filters out specific files will also use\n\nmarkAsFailure()\n.\n\n\n\n\nProviding an alternative mechanism for sending response content\n\n\nIn some cases, you may want to alter how the \nSwoole\\Http\\Response\n receives the\nbody content. By default, we use \nSwoole\\Http\\Response::sendfile()\n. However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the \nGzipMiddleware\n adds a compression filter to\na filehandle representing the file to send, and then calls\n\nSwoole\\Http\\Response::write()\n in a loop until all content is sent.\n\n\nTo perform work like this, you can call the\n\nStaticResourceResponse::setResponseContentCallback()\n method as detailed in the\nsection above within your middleware.\n\n\n\n\nAlternative static resource handlers\n\n\nAs noted at the beginning of this chapter, the \nSwooleRequestHandlerRunner\n\ncomposes a \nStaticResourceHandlerInterface\n instance in order to determine if a\nresource was matched by the request, and then to serve it.\n\n\nIf you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n:\n\n\ndeclare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Attempt to process a static resource based on the current request.\n     *\n     * If the resource cannot be processed, the method should return null.\n     * Otherwise, it should return the StaticResourceResponse that was used\n     * to send the Swoole response instance. The runner can then query this\n     * for content length and status.\n     */\n    public function processStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : ?StaticResourceHandler\\StaticResourceResponse;\n}\n\n\n\nOnce implemented, map the service\n\nZend\\Expressive\\Swoole\\StaticResourceHandlerInterface\n to a factory that\nreturns your custom implementation within your \ndependencies\n configuration.",
            "title": "Static Resources"
        },
        {
            "location": "/v1/static-resources/#static-resources",
            "text": "One feature of a web server is the ability to serve static files from your\nfilesystem. zend-expressive-swoole provides that capability as well.  To enable this, the package provides an alternate RequestHandlerRunner \nimplementation via the class  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner \nthat performs two duties:   If a static resource is matched, it serves that.  Otherwise, it passes off handling to the composed application pipeline.   Internally, the  SwooleRequestHandlerRunner  composes another class, a  Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  instance. This instance\nis passed the Swoole request and response, and returns a value indicating\nwhether or not it was able to identify and serve a matching static resource.  Our default implementation,  Zend\\Expressive\\Swoole\\StaticResourceHandler ,\nprovides an approach that checks an incoming request path against a list of\nknown extensions, and a configured document root. If the extension matches, it\nthen checks to see if the file exists in the document root. If it does, it will\nserve it.",
            "title": "Static Resources"
        },
        {
            "location": "/v1/static-resources/#middleware",
            "text": "The  StaticResourceHandler  implementation performs its work by composing a\nqueue of middleware to execute when attempting to serve a matched file. Using\nthis approach, we are able to provide a configurable set of capabilities for\nserving static resources. What we currently provide is as follows:    CacheControlMiddleware  will set a  Cache-Control  header based on\n  configuration you provide it. Configuration uses a combination of regular\n  expressions to match against the path, with the  Cache-Control  directive to\n  use when the match occurs.    ClearStatCacheMiddleware  will, if configured to do so, call\n   clearstatcache()  either on every request, or at specific intervals. This is\n  useful if you anticipate filesystem changes in your document root.    ContentTypeFilterMiddleware  checks the incoming filename against a map of\n  known extensions and their associated Content-Type values. If it cannot\n  match the file, it returns a value indicating no match was found so that the\n  application can continue processing the request. Otherwise, it provides the\n  Content-Type for the associated response. This middleware is generally best\n  used as the outermost layer, to ensure no other middleware executes in the\n  case that the file cannot be matched.    ETagMiddleware  will set an  ETag  header using either a strong or weak\n  algorithm, and only on files matching given regular expressions. If the  ETag \n  header value matches either an  If-Match  or  If-None-Match  request header,\n  it will provide a response status of  304  and disable sending content.    GzipMiddleware  detects the  Accept-Encoding  request header and, if present,\n  and the compression level provided to the instance allows, it will compress\n  the returned response content using either gzip or deflate compression as\n  requested.    HeadMiddleware  will force an empty response. (The status and headers may be\n  set by other middleware.)    LastModifiedMiddleware  will set a  Last-Modified  header using the\n   filemtime()  value of the requested resource. If the header value is later\n  than an  If-Modified-Since   request header, it will provide a response status\n  of  304  and disable sending content.    MethodNotAllowedMiddleware  will set the response status to  405 , and set an\n   Allow  header indicating the allowed methods when an unsupported request\n  method is provided.    OptionsMiddleware  will force an empty response with an  Allow  header set\n  to the allowed methods. (Other headers may also be present!)    By default, these are registered in the following order, contingent on\nconfiguration being provided:   ContentTypeFilterMiddleware  MethodNotAllowedMiddleware  OptionsMiddleware  HeadMiddleware  GzipMiddleware  ClearStatCacheMiddleware  CacheControlMiddleware  LastModifiedMiddleware  ETagMiddleware   This approach ensures that the most expensive operations are never called unless\nother conditions are met (e.g., if the HTTP request method is not allowed,\nthere's no need to calculate the  Last-Modified  or  ETag  headers); it also\nensures that all possible headers are provided whenever possible (e.g., a  HEAD \nrequest should also expose  Cache-Control ,  Last-Modified , and  ETag \nheaders).",
            "title": "Middleware"
        },
        {
            "location": "/v1/static-resources/#providing-your-own-middleware",
            "text": "If you want to disable middleware, or to provide an alternate list of middleware\n(including your own!), you will need to provide an alternate StaticResourceHandler  factory. In most cases, you can extend StaticResourceHandlerFactory  and override the  configureMiddleware(array\n$config) : array  method to do so. Be sure to remember to add a  dependencies \nsetting mapping the  StaticResourceHandlerInterface  service to your new factory\nwhen done!",
            "title": "Providing your own middleware"
        },
        {
            "location": "/v1/static-resources/#configuration",
            "text": "We provide a factory for the  StaticResourceHandler  that uses a\nconfiguration-driven approach in order to:   Set the document root.  Set the map of allowed extensions to content-types.  Configure and provide middleware.   The following demonstrates all currently available configuration options:  // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                // Document root; defaults to \"getcwd() . '/public'\"\n                'document-root' => '/path/to/static/files/to/serve',\n\n                // Extension => content-type map.\n                // Keys are the extensions to map (minus any leading `.`),\n                // values are the MIME type to use when serving them.\n                // A default list exists if none is provided.\n                'type-map' => [],\n\n                // How often a worker should clear the filesystem stat cache.\n                // If not provided, it will never clear it. The value should be\n                // an integer indicating the number of seconds between clear\n                // operations. 0 or negative values will clear on every request.\n                'clearstatcache-interval' => 3600,\n\n                // Which ETag algorithm to use.\n                // Must be one of \"weak\" or \"strong\"; the default, when none is\n                // provided, is \"weak\".\n                'etag-type' => 'weak|strong',\n\n                // gzip options\n                'gzip' => [\n                    // Compression level to use.\n                    // Should be an integer between 1 and 9; values less than 1\n                    // disable compression.\n                    'level' => 4,\n                ],\n\n                // Rules governing which server-side caching headers are emitted.\n                // Each key must be a valid regular expression, and should match\n                // typically only file extensions, but potentially full paths.\n                // When a static resource matches, all associated rules will apply.\n                'directives' => [\n                    'regex' => [\n                        'cache-control' => [\n                            // one or more valid Cache-Control directives:\n                            // - must-revalidate\n                            // - no-cache\n                            // - no-store\n                            // - no-transform\n                            // - public\n                            // - private\n                            // - max-age=\\d+\n                        ],\n                        'last-modified' => bool, // Emit a Last-Modified header?\n                        'etag' => bool, // Emit an ETag header?\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/v1/static-resources/#security-warning",
            "text": "Never add  php  as an allowed static file extension, as doing so could expose\nthe source code of your PHP application!",
            "title": "Security warning"
        },
        {
            "location": "/v1/static-resources/#document-root",
            "text": "If no  document_root  configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root\ndoes not exist, we raise an exception.",
            "title": "Document root"
        },
        {
            "location": "/v1/static-resources/#default-extensioncontent-types",
            "text": "By default, we serve files with extensions in the whitelist defined in the\nconstant  Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS ,\nwhich is derived from a  list of common web MIME types maintained by Mozilla .",
            "title": "Default extension/content-types"
        },
        {
            "location": "/v1/static-resources/#configuration-example",
            "text": "The example which follows provides the following options:   Sets the document root to  /var/www/htdocs .  Adds a custom extension / content-type map.  Provides a clearstatcache interval of 2 hours.  Selects the \"strong\" ETag algorithm.  Indicates a gzip compression level of 3.  Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files.  Sets Cache-Control directives for plain text files.   // config/autoload/swoole.local.php\n\nreturn [\n    'zend-expressive-swoole' => [\n        'swoole-http-server' => [\n            'static-files' => [\n                'document-root' => '/var/www/htdocs',\n\n                'type-map' => [\n                    'css'   => 'text/css',\n                    'gif'   => 'image/gif',\n                    'ico'   => 'image/x-icon',\n                    'jpg'   => 'image/jpg',\n                    'jpeg'  => 'image/jpg',\n                    'js'    => 'application/javascript',\n                    'png'   => 'image/png',\n                    'svg'   => 'image/svg+xml',\n                    'txt'   => 'text/plain',\n                ],\n\n                'clearstatcache-interval' => 7200,\n\n                'etag-type' => 'strong',\n\n                'gzip' => [\n                    'level' => 3,\n                ],\n\n                'directives' => [\n                    '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-transform',\n                        ],\n                        'last-modified' => true,\n                        'etag' => true,\n                    ],\n                    '/\\.txt$/' => [\n                        'cache-control' => [\n                            'public',\n                            'no-cache',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration Example"
        },
        {
            "location": "/v1/static-resources/#writing-middleware",
            "text": "Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which\ndefines the following:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\ninterface MiddlewareInterface\n{\n    /**\n     * @param string $filename The discovered filename being returned.\n     * @param callable $next has the signature:\n     *     function (Request $request, string $filename) : StaticResourceResponse\n     */\n    public function __invoke(\n        Request $request,\n        string $filename,\n        callable $next\n    ) : StaticResourceResponse;\n}  The  $next  argument has the following signature:  namespace Zend\\Expressive\\Swoole\\StaticResourceHandler;\n\nuse Swoole\\Http\\Request;\n\npublic function __invoke(\n    Request $request,\n    string $filename\n) : StaticResourceResponse;  Typically, middleware will look something like this:  $response = $next($request, $filename);\n\n// if some request condition does not match:\n// return $response;\n\n// Otherwise, manipulate the returned $response instance and then return it.  Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse  instance.\nThat class looks like the following:  class StaticResourceResponse\n{\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function __construct(\n        int $status = 200,\n        array $headers = [],\n        bool $sendContent = true,\n        callable $responseContentCallback = null\n    );\n\n    public function addHeader(string $name, string $value) : void;\n\n    public function disableContent() : void;\n\n    /**\n     * Call this method to indicate that the request cannot be served as a\n     * static resource. The request runner will then proceed to execute\n     * the associated application in order to generate the response.\n     */\n    public function markAsFailure() : void;\n\n    /**\n     * @param callable $responseContentCallback Callback to use when emitting\n     *     the response body content via Swoole. Must have the signature:\n     *     function (SwooleHttpResponse $response, string $filename) : void\n     */\n    public function setResponseContentCallback(callable $callback) : void;\n\n    /**\n     * Use this within a response content callback to set the associated\n     * Content-Length of the generated response. Loggers can then query\n     * for this information in order to provide that information in the logs.\n     */\n    public function setContentLength(int $length) : void;\n\n    public function setStatus(int $status) : void;\n}  Most middleware will conditionally set the status, one or more headers, and\npotentially disable returning the response body (via  disableContent() ).\nMiddleware that restricts access or filters out specific files will also use markAsFailure() .",
            "title": "Writing Middleware"
        },
        {
            "location": "/v1/static-resources/#providing-an-alternative-mechanism-for-sending-response-content",
            "text": "In some cases, you may want to alter how the  Swoole\\Http\\Response  receives the\nbody content. By default, we use  Swoole\\Http\\Response::sendfile() . However,\nthis may not work well when performing tasks such as compression, appending a\nwatermark, etc. As an example, the  GzipMiddleware  adds a compression filter to\na filehandle representing the file to send, and then calls Swoole\\Http\\Response::write()  in a loop until all content is sent.  To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback()  method as detailed in the\nsection above within your middleware.",
            "title": "Providing an alternative mechanism for sending response content"
        },
        {
            "location": "/v1/static-resources/#alternative-static-resource-handlers",
            "text": "As noted at the beginning of this chapter, the  SwooleRequestHandlerRunner \ncomposes a  StaticResourceHandlerInterface  instance in order to determine if a\nresource was matched by the request, and then to serve it.  If you want to provide an alternative mechanism for doing so (e.g., to serve\nfiles out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface :  declare(strict_types=1);\n\nnamespace Zend\\Expressive\\Swoole;\n\nuse Swoole\\Http\\Request as SwooleHttpRequest;\nuse Swoole\\Http\\Response as SwooleHttpResponse;\n\ninterface StaticResourceHandlerInterface\n{\n    /**\n     * Attempt to process a static resource based on the current request.\n     *\n     * If the resource cannot be processed, the method should return null.\n     * Otherwise, it should return the StaticResourceResponse that was used\n     * to send the Swoole response instance. The runner can then query this\n     * for content length and status.\n     */\n    public function processStaticResource(\n        SwooleHttpRequest $request,\n        SwooleHttpResponse $response\n    ) : ?StaticResourceHandler\\StaticResourceResponse;\n}  Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface  to a factory that\nreturns your custom implementation within your  dependencies  configuration.",
            "title": "Alternative static resource handlers"
        },
        {
            "location": "/v1/logging/",
            "text": "Logging\n\n\nWeb servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.\n\n\nOut-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.\n\n\nWe log a number of items:\n\n\n\n\nWhen the web server starts, indicating the host and port on which it is running.\n\n\nWhen workers start, including the working directory and worker ID.\n\n\nWhen the web server stops.\n\n\nWhen the web server reloads workers.\n\n\nEach request (more on this below)\n\n\n\n\nBy default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any \nPSR-3 compliant logger\n to\nlog application details. We emit logs detailing server operations using the\npriority \nPsr\\Log\\LogLevel::NOTICE\n (unless detailing an error, such as\ninability to reload)), while \nPsr\\Log\\LogLevel::INFO\n and \nPsr\\Log\\LogLevel::ERROR\n\nare used to log requests (errors are used for response statuses greater than or\nequal to 400).\n\n\nAccess Logs\n\n\nTechnically, the \nSwooleRequestHandlerRunner\n doesn't use PSR-3 loggers\ndirectly, but, rather, instances of \nZend\\Expressive\\Swoole\\Log\\AccessLogInterface\n.\nThis package-specific interface extends the PSR-3 interface to add two methods:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Request;\nuse Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse;\n\ninterface AccessLogInterface extends LoggerInterface\n{\n    public function logAccessForStaticResource(\n        Request $request,\n        StaticResourceResponse $response\n    ) : void;\n\n    public function logAccessForPsr7Resource(\n        Request $request,\n        ResponseInterface $response\n    ) : void;\n}\n\n\n\nTo allow usage of a standard PSR-3 logger, we also provide a decorator,\n\nZend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator\n, which decorates the PSR-3\nlogger and provides a standard implementation for the two methods listed above.\nIf you have defined a PSR-3 \nLoggerInterface\n service in your application, it\nwill be used automatically.\n\n\nFormatting logs\n\n\nThe Apache web server has long provided flexible and robust logging\ncapabilities, and its formats are used across a variety of web servers and\nlogging platforms. As such, we have chosen to use its formats for our standard\nimplementation. However, we allow you to plug in your own system as needed.\n\n\nYou can refer to the \nApache mod_log_config documentation\n\nin order to understand the available placeholders available for format strings.\n\n\nFormatting is provided to the \nPsr3AccessLogDecorator\n via instances of the\ninterface \nZend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface\n:\n\n\ninterface AccessLogFormatterInterface\n{\n    public function format(AccessLogDataMap $map) : string;\n}\n\n\n\nAccessLogDataMap\n is a class used internally by the \nPsr3AccessLogDecorator\n in\norder to map Apache log placeholders to request/response values.\n\n\nOur default \nAccessLogFormatterInterface\n implementation, \nAccessLogFormatter\n,\nprovides constants referencing the most common formats, but also allows you to\nuse arbitrary log formats that use the standard Apache placeholders. The formats\nwe include by default are:\n\n\n\n\nAccessLogFormatter::FORMAT_COMMON\n: Apache common log format: \n%h %l %u %t \"%r\" %>s %b\n\n\nAccessLogFormatter::FORMAT_COMMON_VHOST\n: Apache common log format + vhost: \n%v %h %l %u %t \"%r\" %>s %b\n\n\nAccessLogFormatter::FORMAT_COMBINED\n: Apache combined log format: \n%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"\n\n\nAccessLogFormatter::FORMAT_REFERER\n: \n%{Referer}i -> %U\n\n\nAccessLogFormatter::FORMAT_AGENT\n: \n%{User-Agent}i\n\n\nAccessLogFormatter::FORMAT_VHOST\n: Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b';\n\n\nAccessLogFormatter::FORMAT_COMMON_DEBIAN\n: Debian variant of common log format: \n%h %l %u %t \u201c%r\u201d %>s %O\n;\n\n\nAccessLogFormatter::FORMAT_COMBINED_DEBIAN\n: Debian variant of combined log format: \n%h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d\n;\n\n\nAccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN\n: Debian variant of combined log format + vhost: \n%v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\"\n;\n\n\n\n\nConfiguring a logger\n\n\nYou may subsitute your own logger implementation into the Swoole request handler\nrunner.\n\n\nManual usage\n\n\nIf you are manually instantiating a \nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n\ninstance, you may provide it as the seventh argument to the constructor:\n\n\nuse Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner;\n\n$runner = new SwooleRequestHandlerRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $pidManager,\n    $serverFactory,\n    $staticResourceHandler,\n    $logger // <-- AccessLoggerInterface instance\n);\n\n\n\nContainer usage\n\n\nIf you are using a \nPSR-11\n container, the\n\nSwooleRequestHandlerRunnerFactory\n will retrieve a log instance using the\n\nZend\\Expressive\\Swoole\\Log\\AccessLogInterface\n service.\n\n\nYou have two options for substituting your own logger from there.\n\n\nFirst, you can create your own factory that produces an \nAccessLogInterface\n\ninstance, and map it to the service. This is the best route if you want to write\nyour own implementation, or want to use a different PSR-3 logger service.\n\n\nIf you are okay with re-using your existing PSR-3 logger, the provided\n\nZend\\Expressive\\Swoole\\Log\\AccessLogFactory\n will use the\n\nPsr\\Log\\LoggerInterface\n service to create a \nPsr3AccessLogDecorator\n instance.\n\n\nThis factory also allows you to specify a custom \nAccessLogFormatterInterface\n\ninstance if you want. It will look up a service by the fully-qualified interface\nname, and use it if present. Otherwise, it creates an \nAccessLogFormatter\n\ninstance for you.\n\n\nThe factory will also look at the following configuration values:\n\n\n'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'format' => string, // one of the AccessLogFormatter::FORMAT_*\n                                // constants, or a custom format string\n            'use-hostname-lookups' => bool, // Set to true to enable hostname lookups\n        ],\n    ],\n],\n\n\n\nUsing Monolog as a PSR-3 logger\n\n\nWhen using \nMonolog\n with a \nStreamHandler\n,\nyou must supply a file or a stream resource descriptor. We recommend using one\nof the following:\n\n\n\n\n\n\nphp://stdout\n is a good choice, as this will generally write to the current\n  console.\n\n\n\n\n\n\nphp://stderr\n is also a good choice, as this will generally write to the\n  current console, and allows you to filter based on that output stream.\n\n\n\n\n\n\nWhen using \nDocker\n, generally one of either\n  \n/proc/1/fd/1\n or \n/proc/1/fd/2\n can be used, and are analogous to \nSTDOUT\n\n  and \nSTDERR\n, respectively.  We recommend using \nphp://stdout\n and\n  \nphp://stderr\n instead, as these will be mapped to the correct locations by\n  the language.\n\n\n\n\n\n\n\n\nErrorLogHandler\n\n\nIf you plan to write to \nSTDERR\n, you might consider instead using the\nMonolog \nErrorLogHandler\n, as this will use PHP's \nerror_log()\n mechanism to\nwrite to the configured PHP error log. You can then either introspect that\nlocation, or configure the \nerror_log\n \nphp.ini\n setting to point to\neither \n/dev/stderr\n or, if on Docker, \n/proc/1/fd/2\n.\n\n\n\n\nAdditionally, we recommend using the \nPsrLogMessageProcessor\n with any Monolog\nhandler to ensure that any templated parameters are expanded by the logger.\n\n\nAs an example, the following is a factory that wires a \nStreamHandler\n to a\n\nMonolog\\Logger\n instance. \n\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\nuse Monolog\\Processor\\PsrLogMessageProcessor;\n\nclass LoggerFactory\n{\n    public function __invoke(ContainerInterface $container) : LoggerInterface\n    {\n        $logger = new Logger('swoole-http-server');\n        $logger->pushHandler(new StreamHandler(\n            'php://stdout',\n            Logger::INFO,\n            $bubble = true,\n            $expandNewLines = true\n        ));\n        $logger->pushProcessor(new PsrLogMessageProcessor());\n        return $logger;\n    }\n}\n\n\n\nIf you then wire this to the \nPsr\\Log\\LoggerInterface\n service, it will be used\nby Swoole for the purposes of access logs as well.",
            "title": "Logging"
        },
        {
            "location": "/v1/logging/#logging",
            "text": "Web servers typically log request details, so that you can perform tasks such as\nanalytics, identification of invalid requests, and more.  Out-of-the-box, Swoole does not do this. As such, we provide these capabilities\nwith this integration.  We log a number of items:   When the web server starts, indicating the host and port on which it is running.  When workers start, including the working directory and worker ID.  When the web server stops.  When the web server reloads workers.  Each request (more on this below)   By default, logging is performed to STDOUT, using an internal logger. However,\nyou can use any  PSR-3 compliant logger  to\nlog application details. We emit logs detailing server operations using the\npriority  Psr\\Log\\LogLevel::NOTICE  (unless detailing an error, such as\ninability to reload)), while  Psr\\Log\\LogLevel::INFO  and  Psr\\Log\\LogLevel::ERROR \nare used to log requests (errors are used for response statuses greater than or\nequal to 400).",
            "title": "Logging"
        },
        {
            "location": "/v1/logging/#access-logs",
            "text": "Technically, the  SwooleRequestHandlerRunner  doesn't use PSR-3 loggers\ndirectly, but, rather, instances of  Zend\\Expressive\\Swoole\\Log\\AccessLogInterface .\nThis package-specific interface extends the PSR-3 interface to add two methods:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Swoole\\Http\\Request;\nuse Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse;\n\ninterface AccessLogInterface extends LoggerInterface\n{\n    public function logAccessForStaticResource(\n        Request $request,\n        StaticResourceResponse $response\n    ) : void;\n\n    public function logAccessForPsr7Resource(\n        Request $request,\n        ResponseInterface $response\n    ) : void;\n}  To allow usage of a standard PSR-3 logger, we also provide a decorator, Zend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3\nlogger and provides a standard implementation for the two methods listed above.\nIf you have defined a PSR-3  LoggerInterface  service in your application, it\nwill be used automatically.",
            "title": "Access Logs"
        },
        {
            "location": "/v1/logging/#formatting-logs",
            "text": "The Apache web server has long provided flexible and robust logging\ncapabilities, and its formats are used across a variety of web servers and\nlogging platforms. As such, we have chosen to use its formats for our standard\nimplementation. However, we allow you to plug in your own system as needed.  You can refer to the  Apache mod_log_config documentation \nin order to understand the available placeholders available for format strings.  Formatting is provided to the  Psr3AccessLogDecorator  via instances of the\ninterface  Zend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface :  interface AccessLogFormatterInterface\n{\n    public function format(AccessLogDataMap $map) : string;\n}  AccessLogDataMap  is a class used internally by the  Psr3AccessLogDecorator  in\norder to map Apache log placeholders to request/response values.  Our default  AccessLogFormatterInterface  implementation,  AccessLogFormatter ,\nprovides constants referencing the most common formats, but also allows you to\nuse arbitrary log formats that use the standard Apache placeholders. The formats\nwe include by default are:   AccessLogFormatter::FORMAT_COMMON : Apache common log format:  %h %l %u %t \"%r\" %>s %b  AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost:  %v %h %l %u %t \"%r\" %>s %b  AccessLogFormatter::FORMAT_COMBINED : Apache combined log format:  %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"  AccessLogFormatter::FORMAT_REFERER :  %{Referer}i -> %U  AccessLogFormatter::FORMAT_AGENT :  %{User-Agent}i  AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b';  AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format:  %h %l %u %t \u201c%r\u201d %>s %O ;  AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format:  %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d ;  AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost:  %v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\" ;",
            "title": "Formatting logs"
        },
        {
            "location": "/v1/logging/#configuring-a-logger",
            "text": "You may subsitute your own logger implementation into the Swoole request handler\nrunner.",
            "title": "Configuring a logger"
        },
        {
            "location": "/v1/logging/#manual-usage",
            "text": "If you are manually instantiating a  Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner \ninstance, you may provide it as the seventh argument to the constructor:  use Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner;\n\n$runner = new SwooleRequestHandlerRunner(\n    $application,\n    $serverRequestFactory,\n    $serverRequestErrorResponseGenerator,\n    $pidManager,\n    $serverFactory,\n    $staticResourceHandler,\n    $logger // <-- AccessLoggerInterface instance\n);",
            "title": "Manual usage"
        },
        {
            "location": "/v1/logging/#container-usage",
            "text": "If you are using a  PSR-11  container, the SwooleRequestHandlerRunnerFactory  will retrieve a log instance using the Zend\\Expressive\\Swoole\\Log\\AccessLogInterface  service.  You have two options for substituting your own logger from there.  First, you can create your own factory that produces an  AccessLogInterface \ninstance, and map it to the service. This is the best route if you want to write\nyour own implementation, or want to use a different PSR-3 logger service.  If you are okay with re-using your existing PSR-3 logger, the provided Zend\\Expressive\\Swoole\\Log\\AccessLogFactory  will use the Psr\\Log\\LoggerInterface  service to create a  Psr3AccessLogDecorator  instance.  This factory also allows you to specify a custom  AccessLogFormatterInterface \ninstance if you want. It will look up a service by the fully-qualified interface\nname, and use it if present. Otherwise, it creates an  AccessLogFormatter \ninstance for you.  The factory will also look at the following configuration values:  'zend-expressive-swoole' => [\n    'swoole-http-server' => [\n        'logger' => [\n            'format' => string, // one of the AccessLogFormatter::FORMAT_*\n                                // constants, or a custom format string\n            'use-hostname-lookups' => bool, // Set to true to enable hostname lookups\n        ],\n    ],\n],",
            "title": "Container usage"
        },
        {
            "location": "/v1/logging/#using-monolog-as-a-psr-3-logger",
            "text": "When using  Monolog  with a  StreamHandler ,\nyou must supply a file or a stream resource descriptor. We recommend using one\nof the following:    php://stdout  is a good choice, as this will generally write to the current\n  console.    php://stderr  is also a good choice, as this will generally write to the\n  current console, and allows you to filter based on that output stream.    When using  Docker , generally one of either\n   /proc/1/fd/1  or  /proc/1/fd/2  can be used, and are analogous to  STDOUT \n  and  STDERR , respectively.  We recommend using  php://stdout  and\n   php://stderr  instead, as these will be mapped to the correct locations by\n  the language.",
            "title": "Using Monolog as a PSR-3 logger"
        },
        {
            "location": "/v1/logging/#errorloghandler",
            "text": "If you plan to write to  STDERR , you might consider instead using the\nMonolog  ErrorLogHandler , as this will use PHP's  error_log()  mechanism to\nwrite to the configured PHP error log. You can then either introspect that\nlocation, or configure the  error_log   php.ini  setting to point to\neither  /dev/stderr  or, if on Docker,  /proc/1/fd/2 .   Additionally, we recommend using the  PsrLogMessageProcessor  with any Monolog\nhandler to ensure that any templated parameters are expanded by the logger.  As an example, the following is a factory that wires a  StreamHandler  to a Monolog\\Logger  instance.   use Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\nuse Monolog\\Processor\\PsrLogMessageProcessor;\n\nclass LoggerFactory\n{\n    public function __invoke(ContainerInterface $container) : LoggerInterface\n    {\n        $logger = new Logger('swoole-http-server');\n        $logger->pushHandler(new StreamHandler(\n            'php://stdout',\n            Logger::INFO,\n            $bubble = true,\n            $expandNewLines = true\n        ));\n        $logger->pushProcessor(new PsrLogMessageProcessor());\n        return $logger;\n    }\n}  If you then wire this to the  Psr\\Log\\LoggerInterface  service, it will be used\nby Swoole for the purposes of access logs as well.",
            "title": "ErrorLogHandler"
        },
        {
            "location": "/v1/how-it-works/",
            "text": "How it works\n\n\nWhen you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface, \nwithout using a web server\n.\n\n\nThis sounds a bit strange in PHP, though it will be familiar to \nNode.js\n\ndevelopers; the execution model under Swoole is similar to that technology.\n\n\nThe HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the \non(string $name, callable $action)\n method.\n\n\nThe request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the \non('request')\n\nevent of \nSwoole\\Http\\Server\n. This runner is implemented in the\n\nZend\\Expressive\\Swoole\\SwooleRequestHandlerRunner\n class.\n\n\nThe basic implementation looks similar to the following:\n\n\npublic function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}\n\n\n\nThis package provides a bridge between \nSwoole\\Http\\Request\n (\n$request\n) and\n\nPSR-7\n requests (\n$psr7Request\n;\nspecifically as implemented by \nzend-diactoros\n)\nvia the class \nZend\\Expressive\\Swoole\\ServerRequestSwooleFactory\n.\n\n\nIt also provides a Swoole-specific emitter, \nZend\\Expressive\\Swoole\\SwooleEmitter\n,\nthat converts a PSR-7 response to a \nSwoole\\Http\\Response\n instance.\n\n\nWhen you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4 \nworker\n\n(or \nreactor\n) processes and 1 \nmaster\n process, for a total of 5 PHP processes.\n\n\n\n\nThe advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.\n\n\nPerformance\n\n\nThe ZF developers performed a benchmark running the default \nzend-expressive-skeleton\n\napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.\n\n\nThe results demonstrated that \nExpressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache\n.\n\n\nThis impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.\n\n\nUnder Swoole 4.1+, for even better performance, you can enable the option\n\nzend-expressive-swoole.swoole-http-server.options.enable_coroutine\n. When this\nis enabled, Swoole will run most I/O processes in coroutines. Doing so provides\napproximately \n10 times faster performance\n than without coroutines, meaning a\nSwoole-based application can be 40 to 50 times faster than running under nginx\nor Apache. Performance improves with the number of workers (which are restricted\nby the amount of memory); as such, performance can increase from these numbers.",
            "title": "How it works"
        },
        {
            "location": "/v1/how-it-works/#how-it-works",
            "text": "When you run an Expressive application using Swoole, you will execute PHP from\nthe command line interface,  without using a web server .  This sounds a bit strange in PHP, though it will be familiar to  Node.js \ndevelopers; the execution model under Swoole is similar to that technology.  The HTTP server of Swoole is a PHP class that offers callbacks on a number of events,\nusing the  on(string $name, callable $action)  method.  The request handler implemented in zend-expressive-swoole is a runner that\nenables the execution of an Expressive application inside the  on('request') \nevent of  Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner  class.  The basic implementation looks similar to the following:  public function run() : void\n{\n    $this->swooleHttpServer->on('start', function ($server) {\n        printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port);\n    });\n\n    $this->swooleHttpServer->on('request', function ($request, $response) {\n        printf(\n            \"%s - %s - %s %s\\n\",\n            date('Y-m-d H:i:sO', time()),\n            $request->server['remote_addr'],\n            $request->server['request_method'],\n            $request->server['request_uri']\n        );\n        $emitter = new SwooleEmitter($response);\n        try {\n            $psr7Request = ($this->serverRequestFactory)($request);\n        } catch (Throwable $e) {\n            // Error in generating the request\n            $this->emitMarshalServerRequestException($emitter, $e);\n            return;\n        }\n        $emitter->emit($this->handler->handle($psr7Request));\n    });\n\n    $this->swooleHttpServer->start();\n}  This package provides a bridge between  Swoole\\Http\\Request  ( $request ) and PSR-7  requests ( $psr7Request ;\nspecifically as implemented by  zend-diactoros )\nvia the class  Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory .  It also provides a Swoole-specific emitter,  Zend\\Expressive\\Swoole\\SwooleEmitter ,\nthat converts a PSR-7 response to a  Swoole\\Http\\Response  instance.  When you run an Expressive application using zend-expressive-swoole, you will\nnotice a bunch of PHP processes running. By default, Swoole executes 4  worker \n(or  reactor ) processes and 1  master  process, for a total of 5 PHP processes.   The advantages of this architecture are many: it's very light and simple (just\nPHP processes running); it offers a service layer that is able to restart a\nworker automatically if it's not responding; and it allows executing multiple\nHTTP requests in parallel. The architecture is built for scaling.",
            "title": "How it works"
        },
        {
            "location": "/v1/how-it-works/#performance",
            "text": "The ZF developers performed a benchmark running the default  zend-expressive-skeleton \napplication with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php)\nusing PHP 7.2.7.  The results demonstrated that  Expressive with Swoole runs 4 to 5 times faster\nthan nginx or Apache .  This impressive result is primarily due to the shared memory approach of Swoole.\nUnlike traditional apache/php-fpm usage, the memory allocated in Swoole will not\nbe freed after a request. This allows application configuration and artifacts\n(such as middleware and handlers) to persist between requests and processes.  Under Swoole 4.1+, for even better performance, you can enable the option zend-expressive-swoole.swoole-http-server.options.enable_coroutine . When this\nis enabled, Swoole will run most I/O processes in coroutines. Doing so provides\napproximately  10 times faster performance  than without coroutines, meaning a\nSwoole-based application can be 40 to 50 times faster than running under nginx\nor Apache. Performance improves with the number of workers (which are restricted\nby the amount of memory); as such, performance can increase from these numbers.",
            "title": "Performance"
        },
        {
            "location": "/v1/considerations/",
            "text": "Considerations when using Swoole\n\n\nBecause Swoole uses an event loop, and because it is able to load your\napplication exactly once, you must take several precautions when using it to\nserve your application.\n\n\nLong-running processes\n\n\nWhen using the Swoole HTTP server, your application runs within an \nevent\nloop\n. One benefit of this is that you\ncan then \ndefer\n\nexecution of code until the next tick of the loop. This can be used to delay\nlong-running code from executing until after a response has been sent to the\nclient, which can obviate the need for tools such as message queues.\n\n\nThe problem, however, is that when a worker \ndoes\n begin to handle the deferred\nfunctionality, it will run as long as needed until the work is done. This then\nmeans that the worker is \nblocked\n from handling new requests until that work is\ndone.\n\n\nIf you have enough workers, or the number of such long-running processes if few\nand far-between, this may not be an issue for you. However, it is a commonly\ndocumented issue in other similar systems such as Node.js. \nThe solution in these\ncases is the same as for general PHP applications: add a message queue to your\nsystems infrastructure, and delegate such work to the message queue instead.\n\n\n\n\nPDO Coroutine Support\n\n\nPlease be aware that enabling coroutine support with \nSwoole\\Runtime::enableCoroutine()\n\nonly decorates MySql PDO connections with coroutines; other drivers (e.g.,\npdo_pgsql) remain blocking as of Swoole 4.1.2.  > For more details,\n\nvisit the related bug report on the Swoole issue tracker\n.\n\n\n\n\nSessions\n\n\nBecause Swoole runs as a PHP CLI application, it generally does not play well\nwith the PHP Session extension. However, there are alternatives.\n\n\nzend-expressive-session-cache\n\n\nzend-expressive-session-cache\n\nprovides a persistence adapter for \nzend-expressive-session\n\nthat uses a \nPSR-6 CacheItemPoolInterface implementation\n\nfor storing and retrieving sessions. This approach requires that you setup a\nbackend cache storage for your session data.\n\n\npsr7-sessions/storageless\n\n\nPSR7Session\n provides session\nmiddleware that uses \nJWT tokens\n within\nthe session cookie to transmit session data between the server and client.\nThis approach requires no central session storage, but does impose limits on the\namount of information you can store in a session.\n\n\nStateless services\n\n\nThe typical PHP model is that the engine is fired up, runs your code, and then\ntears down again, \nfor every single request\n. As such, PHP is said to have a\n\"shared nothing architecture\". This is a tremendous boon to developers, as they\ncan ignore things found in lower level languages, such as garbage cleanup,\nmemory management, and more.\n\n\nThis model also comes with a cost: every single request requires bootstrapping\nyour application. Benchmarks we have performed show that bootstrapping is often\nthe most expensive operation in applications, often accounting for 25-50% of\ntotal resource usage and execution time.\n\n\nOne reason technologies such as Swoole can provide a performance boost is due to\nthe fact that they can bootstrap your application exactly once, often during\nstartup. This alone can account for the performance boost of many applications.\n\n\nHowever, it has a price: you now need to consider what changes may happen inside\nthe various classes in your dependency injection container, and the impact those\nchanges may have on later requests, or even other requests happening\nconcurrently.\n\n\nAs one example: \nzend-expressive-template\n\nprovides an interface, \nTemplateRendererInterface\n, that allows you to render a\ntemplate. That interface also allows you to provide template paths, and default\nparameters to pass to every template, and these methods are often invoked within\nfactories or delegators in order to configure the renderer implementation.\nHowever, we have \nalso documented using \naddDefaultParam()\n for passing values\ndiscovered in the request to later handlers\n.\nThis practice accumulates \nstate\n in the renderer that can cause problems later:\n\n\n\n\n\n\nFlash messages discovered in one request might then be pushed to templates\n  renderered in subsequent requests \u2014 when they are no longer in scope. \n\n\n\n\n\n\nUser details from one request might persist to a template rendered for an\n  unauthenticated user in another request, exposing information.\n\n\n\n\n\n\nThese are clearly problematic behaviors!\n\n\nAs such, you must guard against state in services you provide in your dependency\ninjection container, as any state changes have ramifications for other requests.\nWrite services to be stateless, and/or mark state-changing methods as\n\n@internal\n to prevent users from calling them in non-bootstrap code.\n\n\nIf the services are provided by a third party, you have a few options:\n\n\n\n\n\n\nDecorating an existing service that implements an interface to make it\n  stateless.\n\n\n\n\n\n\nExtending a service to make state-changing methods no-ops.\n\n\n\n\n\n\nInjecting factories that produce the stateful services, instead of the service\n  itself.\n\n\n\n\n\n\nWe'll look at each in detail.\n\n\nDecoration\n\n\nIf a service implements an interface, you can decorate the service to make it\nstateless. Well-written interfaces will be stateless by design, and not provide\nmethods meant to internally change state. In these situations, you can create a\nproxy class that decorates the original service:\n\n\nclass ProxyService implements OriginalInterface\n{\n    /** @var OriginalInterface */\n    private $proxy;\n\n    public function __construct(OriginalInterface $proxy)\n    {\n        $this->proxy = $proxy;\n    }\n\n    public function someMethodDefinedInInterface(string $argument) : Result\n    {\n        return $this->proxy->someMethodDefinedInInterface($argument);\n    }\n}\n\n\n\nYou would then:\n\n\n\n\nMap the factory for the original service to the implementation name.\n\n\nCreate a factory that consumes the original service, and produces the proxy.\n\n\nMap the interface name to the factory that creates the proxy.\n\n\n\n\n// in config/autoload/dependencies.global.php:\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            OriginalImplementation::class => OriginalImplementationFactory::class,\n            OriginalInterface::class => ProxyServiceFactory::class,\n        ],\n    ],\n];\n\n\n\nIf you were writing to the interface, and not the implementation, you can now\nguarantee that any non-interface methods that changed state can now no longer be\ncalled.\n\n\nIf the interface itself defines methods that modify state, we recommend writing\na proxy that implements those methods as no-ops and/or that raises exceptions\nwhen those methods are invoked. (The latter approach ensures that you discover\nquickly when code is exercising those methods.) In each case, you would then use\na \ndelegator factory\n,\nto decorate the original instance in the proxy class:\n\n\nfunction (ContainerInterface $container, string $name, callable $callback)\n{\n    return new ProxyService($callback());\n}\n\n\n\n(You can also use the delegator factory approach with the previous proxy service\nexample.)\n\n\nExtension\n\n\nWhen a service does not implement an interface, but exposes methods that change\ninternal state, you can extend the original class to make the methods that\nchange state into no-ops, or have them raise exceptions. (The latter approach\nensures that you discover quickly when code is exercising those methods.)\n\n\nAs an example, let's say you have a class \nDataMapper\n that defines a method\n\nsetTable()\n in it, and that method would change the database table the mapper\nwould query. This is a potentially bad situation!\n\n\nWe could extend the class as follows:\n\n\nclass StatelessDataMapper extends DataMapper\n{\n    public function setTable(string $table) : void\n    {\n        throw new \\DomainException(sprintf(\n            '%s should not be called in production code!',\n            __METHOD__\n        ));\n    }\n}\n\n\n\nIn your factory that creates an instance of \nDataMapper\n, have it instead return\na \nStatelessDataMapper\n instance, and you're now safe.\n\n\nFactories\n\n\nAnother approach is to modify your consuming code to accept a \nfactory\n that\nwill produce the service you'll consume, instead of the service itself. This\napproach ensures that the service is created only when needed, mitigating any\nstate change issues.\n\n\nAs an example, consider the following middleware that currently consumes a\ntemplate renderer:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var TemplateRendererInterface */\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        return new HtmlResponse($this->renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}\n\n\n\nWhat we will do is modify it to accept a \ncallable\n to the constructor. We will\nthen call that factory \njust before\n we need the renderer; we \nwill not\n store\nthe result in the handler, as we want to ensure we have a new instance each\ntime.\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var callable */\n    private $rendererFactory;\n\n    public function __construct(callable $rendererFactory)\n    {\n        $this->rendererFactory = $rendererFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        /** @var TemplateRendererInterface $renderer */\n        $renderer = ($this->rendererFactory)();\n        return new HtmlResponse($renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}\n\n\n\nFrom here, we create a factory for our dependency injection container that will\nreturn the factory we use here. As an example, if we are using the \nzend-view\nintegration\n,\nwe might do the following:\n\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Expressive\\ZendView\\ZendViewRendererFactory;\n\nclass ZendViewRendererFactoryFactory\n{\n    public function __invoke(ContainerInterface $container) : callable\n    {\n        $factory = new ZendViewRendererFactory();\n        return function () use ($container, $factory) : TemplateRendererInterface {\n            return $factory($container);\n        };\n    }\n}\n\n\n\nIf we mapped this to the \"service\" \nZend\\Expressive\\Template\\TemplateRendererInterfaceFactory\n,\nour factory for the \nSomeHandler\n class would then look like:\n\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory;\n\nfunction (ContainerInterface $container) : SomeHandler\n{\n    return new SomeHandler(\n        $container->get(TemplateRendererInterfaceFactory::class)\n    );\n}\n\n\n\nThis approach ensures we get a new instance with known state at precisely the\nmoment we wish to execute the functionality. By ensuring we \ndo not\n store the\ninstance in any way, we also ensure it is garbage collected when the instance\ngoes out of scope (i.e., when the method ends).\n\n\n\n\nHandling the template data problem\n\n\nIf we want our services to be stateless, how do we handle problems such as the \n\ndocumented \naddDefaultParam()\n issue referenced earlier\n?\n\n\nIn this case, the original problem was \"how do we get common request data into\ntemplates?\" The solution originally provided was to alter the state of the\ntemplate renderer. Another solution, however, is one we've also documented\npreviously: \nuse server attributes to pass data between middleware\n.\n\n\nIn this particular case, the middleware documented in the original solution\ncould be modified to provide data to a request attribute, instead of altering\nthe state of the template renderer. It might then become:\n\n\nnamespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Session\\Authentication\\UserInterface;\nuse Zend\\Expressive\\Session\\Flash\\FlashMessagesInterface;\n\nclass TemplateDefaultsMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $routeResult = $request->getAttribute(RouteResult::class);\n        $flashMessages = $request->getAttribute(FlashMessagesInterface::class);\n\n        $defaults = [\n            // Inject the current user, or null if there isn't one.\n            // This is named security so it will not interfere with your user admin pages\n            'security' => $request->getAttribute(UserInterface::class),\n\n            // Inject the currently matched route name.\n            'matchedRouteName' => $routeResult ? $routeResult->getMatchedRouteName() : null,\n\n            // Inject all flash messages\n            'notifications' => $flashMessages ? $flashMessages->getFlashes() : [],\n        ];\n\n        return $handler->handle($request->withAttribute(__CLASS__, $defaults));\n    }\n}\n\n\n\nOnce that change is made, you would then change your handler to do the\nfollowing:\n\n\n\n\nPull that attribute, providing a default \n[]\n value.\n\n\nMerge the pulled value with any local values when rendering the template.\n\n\n\n\nFor example:\n\n\n$defaultParams = $request->getAttribute(TemplateDefaultsMiddleware::class, []);\nreturn new HtmlResponse($renderer->render(\n    'some::template',\n    array_merge($defaultParams, [\n        // handler-specific parameters here\n    ])\n));\n\n\n\nThis approach, while it requires more work on the part of handler authors,\nensures that the renderer state does not vary between requests, making it\nsafer for usage with Swoole and other long-running processes.",
            "title": "Considerations when using Swoole"
        },
        {
            "location": "/v1/considerations/#considerations-when-using-swoole",
            "text": "Because Swoole uses an event loop, and because it is able to load your\napplication exactly once, you must take several precautions when using it to\nserve your application.",
            "title": "Considerations when using Swoole"
        },
        {
            "location": "/v1/considerations/#long-running-processes",
            "text": "When using the Swoole HTTP server, your application runs within an  event\nloop . One benefit of this is that you\ncan then  defer \nexecution of code until the next tick of the loop. This can be used to delay\nlong-running code from executing until after a response has been sent to the\nclient, which can obviate the need for tools such as message queues.  The problem, however, is that when a worker  does  begin to handle the deferred\nfunctionality, it will run as long as needed until the work is done. This then\nmeans that the worker is  blocked  from handling new requests until that work is\ndone.  If you have enough workers, or the number of such long-running processes if few\nand far-between, this may not be an issue for you. However, it is a commonly\ndocumented issue in other similar systems such as Node.js.  The solution in these\ncases is the same as for general PHP applications: add a message queue to your\nsystems infrastructure, and delegate such work to the message queue instead.",
            "title": "Long-running processes"
        },
        {
            "location": "/v1/considerations/#pdo-coroutine-support",
            "text": "Please be aware that enabling coroutine support with  Swoole\\Runtime::enableCoroutine() \nonly decorates MySql PDO connections with coroutines; other drivers (e.g.,\npdo_pgsql) remain blocking as of Swoole 4.1.2.  > For more details, visit the related bug report on the Swoole issue tracker .",
            "title": "PDO Coroutine Support"
        },
        {
            "location": "/v1/considerations/#sessions",
            "text": "Because Swoole runs as a PHP CLI application, it generally does not play well\nwith the PHP Session extension. However, there are alternatives.",
            "title": "Sessions"
        },
        {
            "location": "/v1/considerations/#zend-expressive-session-cache",
            "text": "zend-expressive-session-cache \nprovides a persistence adapter for  zend-expressive-session \nthat uses a  PSR-6 CacheItemPoolInterface implementation \nfor storing and retrieving sessions. This approach requires that you setup a\nbackend cache storage for your session data.",
            "title": "zend-expressive-session-cache"
        },
        {
            "location": "/v1/considerations/#psr7-sessionsstorageless",
            "text": "PSR7Session  provides session\nmiddleware that uses  JWT tokens  within\nthe session cookie to transmit session data between the server and client.\nThis approach requires no central session storage, but does impose limits on the\namount of information you can store in a session.",
            "title": "psr7-sessions/storageless"
        },
        {
            "location": "/v1/considerations/#stateless-services",
            "text": "The typical PHP model is that the engine is fired up, runs your code, and then\ntears down again,  for every single request . As such, PHP is said to have a\n\"shared nothing architecture\". This is a tremendous boon to developers, as they\ncan ignore things found in lower level languages, such as garbage cleanup,\nmemory management, and more.  This model also comes with a cost: every single request requires bootstrapping\nyour application. Benchmarks we have performed show that bootstrapping is often\nthe most expensive operation in applications, often accounting for 25-50% of\ntotal resource usage and execution time.  One reason technologies such as Swoole can provide a performance boost is due to\nthe fact that they can bootstrap your application exactly once, often during\nstartup. This alone can account for the performance boost of many applications.  However, it has a price: you now need to consider what changes may happen inside\nthe various classes in your dependency injection container, and the impact those\nchanges may have on later requests, or even other requests happening\nconcurrently.  As one example:  zend-expressive-template \nprovides an interface,  TemplateRendererInterface , that allows you to render a\ntemplate. That interface also allows you to provide template paths, and default\nparameters to pass to every template, and these methods are often invoked within\nfactories or delegators in order to configure the renderer implementation.\nHowever, we have  also documented using  addDefaultParam()  for passing values\ndiscovered in the request to later handlers .\nThis practice accumulates  state  in the renderer that can cause problems later:    Flash messages discovered in one request might then be pushed to templates\n  renderered in subsequent requests \u2014 when they are no longer in scope.     User details from one request might persist to a template rendered for an\n  unauthenticated user in another request, exposing information.    These are clearly problematic behaviors!  As such, you must guard against state in services you provide in your dependency\ninjection container, as any state changes have ramifications for other requests.\nWrite services to be stateless, and/or mark state-changing methods as @internal  to prevent users from calling them in non-bootstrap code.  If the services are provided by a third party, you have a few options:    Decorating an existing service that implements an interface to make it\n  stateless.    Extending a service to make state-changing methods no-ops.    Injecting factories that produce the stateful services, instead of the service\n  itself.    We'll look at each in detail.",
            "title": "Stateless services"
        },
        {
            "location": "/v1/considerations/#decoration",
            "text": "If a service implements an interface, you can decorate the service to make it\nstateless. Well-written interfaces will be stateless by design, and not provide\nmethods meant to internally change state. In these situations, you can create a\nproxy class that decorates the original service:  class ProxyService implements OriginalInterface\n{\n    /** @var OriginalInterface */\n    private $proxy;\n\n    public function __construct(OriginalInterface $proxy)\n    {\n        $this->proxy = $proxy;\n    }\n\n    public function someMethodDefinedInInterface(string $argument) : Result\n    {\n        return $this->proxy->someMethodDefinedInInterface($argument);\n    }\n}  You would then:   Map the factory for the original service to the implementation name.  Create a factory that consumes the original service, and produces the proxy.  Map the interface name to the factory that creates the proxy.   // in config/autoload/dependencies.global.php:\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            OriginalImplementation::class => OriginalImplementationFactory::class,\n            OriginalInterface::class => ProxyServiceFactory::class,\n        ],\n    ],\n];  If you were writing to the interface, and not the implementation, you can now\nguarantee that any non-interface methods that changed state can now no longer be\ncalled.  If the interface itself defines methods that modify state, we recommend writing\na proxy that implements those methods as no-ops and/or that raises exceptions\nwhen those methods are invoked. (The latter approach ensures that you discover\nquickly when code is exercising those methods.) In each case, you would then use\na  delegator factory ,\nto decorate the original instance in the proxy class:  function (ContainerInterface $container, string $name, callable $callback)\n{\n    return new ProxyService($callback());\n}  (You can also use the delegator factory approach with the previous proxy service\nexample.)",
            "title": "Decoration"
        },
        {
            "location": "/v1/considerations/#extension",
            "text": "When a service does not implement an interface, but exposes methods that change\ninternal state, you can extend the original class to make the methods that\nchange state into no-ops, or have them raise exceptions. (The latter approach\nensures that you discover quickly when code is exercising those methods.)  As an example, let's say you have a class  DataMapper  that defines a method setTable()  in it, and that method would change the database table the mapper\nwould query. This is a potentially bad situation!  We could extend the class as follows:  class StatelessDataMapper extends DataMapper\n{\n    public function setTable(string $table) : void\n    {\n        throw new \\DomainException(sprintf(\n            '%s should not be called in production code!',\n            __METHOD__\n        ));\n    }\n}  In your factory that creates an instance of  DataMapper , have it instead return\na  StatelessDataMapper  instance, and you're now safe.",
            "title": "Extension"
        },
        {
            "location": "/v1/considerations/#factories",
            "text": "Another approach is to modify your consuming code to accept a  factory  that\nwill produce the service you'll consume, instead of the service itself. This\napproach ensures that the service is created only when needed, mitigating any\nstate change issues.  As an example, consider the following middleware that currently consumes a\ntemplate renderer:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var TemplateRendererInterface */\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        return new HtmlResponse($this->renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}  What we will do is modify it to accept a  callable  to the constructor. We will\nthen call that factory  just before  we need the renderer; we  will not  store\nthe result in the handler, as we want to ensure we have a new instance each\ntime.  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    /** @var callable */\n    private $rendererFactory;\n\n    public function __construct(callable $rendererFactory)\n    {\n        $this->rendererFactory = $rendererFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        /** @var TemplateRendererInterface $renderer */\n        $renderer = ($this->rendererFactory)();\n        return new HtmlResponse($renderer->render(\n            'app::some-handler',\n            []\n        ));\n    }\n}  From here, we create a factory for our dependency injection container that will\nreturn the factory we use here. As an example, if we are using the  zend-view\nintegration ,\nwe might do the following:  \nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Expressive\\ZendView\\ZendViewRendererFactory;\n\nclass ZendViewRendererFactoryFactory\n{\n    public function __invoke(ContainerInterface $container) : callable\n    {\n        $factory = new ZendViewRendererFactory();\n        return function () use ($container, $factory) : TemplateRendererInterface {\n            return $factory($container);\n        };\n    }\n}  If we mapped this to the \"service\"  Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory ,\nour factory for the  SomeHandler  class would then look like:  use Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory;\n\nfunction (ContainerInterface $container) : SomeHandler\n{\n    return new SomeHandler(\n        $container->get(TemplateRendererInterfaceFactory::class)\n    );\n}  This approach ensures we get a new instance with known state at precisely the\nmoment we wish to execute the functionality. By ensuring we  do not  store the\ninstance in any way, we also ensure it is garbage collected when the instance\ngoes out of scope (i.e., when the method ends).",
            "title": "Factories"
        },
        {
            "location": "/v1/considerations/#handling-the-template-data-problem",
            "text": "If we want our services to be stateless, how do we handle problems such as the  documented  addDefaultParam()  issue referenced earlier ?  In this case, the original problem was \"how do we get common request data into\ntemplates?\" The solution originally provided was to alter the state of the\ntemplate renderer. Another solution, however, is one we've also documented\npreviously:  use server attributes to pass data between middleware .  In this particular case, the middleware documented in the original solution\ncould be modified to provide data to a request attribute, instead of altering\nthe state of the template renderer. It might then become:  namespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Session\\Authentication\\UserInterface;\nuse Zend\\Expressive\\Session\\Flash\\FlashMessagesInterface;\n\nclass TemplateDefaultsMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $routeResult = $request->getAttribute(RouteResult::class);\n        $flashMessages = $request->getAttribute(FlashMessagesInterface::class);\n\n        $defaults = [\n            // Inject the current user, or null if there isn't one.\n            // This is named security so it will not interfere with your user admin pages\n            'security' => $request->getAttribute(UserInterface::class),\n\n            // Inject the currently matched route name.\n            'matchedRouteName' => $routeResult ? $routeResult->getMatchedRouteName() : null,\n\n            // Inject all flash messages\n            'notifications' => $flashMessages ? $flashMessages->getFlashes() : [],\n        ];\n\n        return $handler->handle($request->withAttribute(__CLASS__, $defaults));\n    }\n}  Once that change is made, you would then change your handler to do the\nfollowing:   Pull that attribute, providing a default  []  value.  Merge the pulled value with any local values when rendering the template.   For example:  $defaultParams = $request->getAttribute(TemplateDefaultsMiddleware::class, []);\nreturn new HtmlResponse($renderer->render(\n    'some::template',\n    array_merge($defaultParams, [\n        // handler-specific parameters here\n    ])\n));  This approach, while it requires more work on the part of handler authors,\nensures that the renderer state does not vary between requests, making it\nsafer for usage with Swoole and other long-running processes.",
            "title": "Handling the template data problem"
        },
        {
            "location": "/intro/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-swoole/v1/intro/';\n  });",
            "title": "_introduction"
        },
        {
            "location": "/static-resources/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-swoole/v1/static-resources/';\n  });",
            "title": "_static-resources"
        },
        {
            "location": "/logging/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-swoole/v1/logging/';\n  });",
            "title": "_logging"
        },
        {
            "location": "/how_it_works/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-swoole/v1/how-it-works/';\n  });",
            "title": "_how-it-works"
        }
    ]
}